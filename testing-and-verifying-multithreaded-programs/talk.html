<!DOCTYPE html>
<html>
   <head>
      <title>Testing and Verifying Multi-Threaded Programs</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <link rel="stylesheet" type="text/css" href="talk.css"/>
   </head>
   <body>
      <textarea id="source">





<!-- section:Title -->

class: slide_title, no_number
count: false

# Automated Verification of Multi-Threaded Programs
### Susanne van den Elsen
Software Developer @ Native Instruments

### Meeting C++
November 10, 2017

???
Good afternoon, welcome everybody and thank you for coming,
- My name is Susanne van den Elsen and I am a C++ Software Developer @ Native Instruments
- Before joining NI I was doing research @ MPI-SWS
- Research focus: automated software verification
- In one of my projects I specifically looked at automated verification of multi-threaded software
  which is also the topic of my talk today
- In particular, I would like to give an introduction to systematic exploration of multi-threaded
  programs and demonstrate a systematic exploration tool I developed in the context of my research.

<!--
}
end_section:section:Title -->


???
In general, concurrency bugs arise from the fact that multiple threads are sharing the same resources.
In this talk I focus on three types of bugs.


--
count: false
##### Race Conditions
Arise when the program's correctness depends on the relative timing or ordering of thread 
instructions

--
count: false
##### Data Races
Arise when two threads
- access the same memory location concurrently; and 
- at least one of the accesses is a write

???
Data Races:
Since the C++11 memory model we can reason about memory accesses and dataraces are deemed undefined 
behaviour (so it is very important to make sure your programs are datarace free)

--
count: false
##### Deadlocks
Situation where a set of threads is blocked indefinitely because each of them is waiting for 
one of the others to release a held resource
 
<!-- <<< -->

<!-- >>> Slide -->

---

<div class="h_example" style="margin-bottom: 2em;">data_race.cpp</div>
<div class="code_left" style="width: 35%;"><pre><code class="language-cpp">
int main()
{
   int x;
   
   thread thr1([&x](){
      x = 1;
   });
   
   thread thr1([&x](){
      x = 2;
   });
   
   thr1.join();
   thr2.join();
}
</code></pre></div>

<!-- TODO: NOTES -->

--
count: false
<div class="code_right" style="width: 60%;"><pre><code class="language-bash">
clang++ -fsanitize=thread -std=c++14 -g data_race.cpp \
   -o data_race

./data_race
</code></pre></div>

???
Compiling the program to be analyzed with the -fsanitize flag will instrument the program with calls
to the TSan runtime library and link the runtime library to the final executable.

--
exclude: true
<br/>
<img src='./generated_trees/trace_analysis/data_race.png' height="250"/>

<!-- TODO: Explain how the happens-before data race detection works? -->

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="h_example" style="margin-bottom: 2em;">deadlock.cpp</div>
<div class="code_left" style="width: 35%;"><pre><code class="language-cpp">
int main()
{
   mutex m1, m2;
   
   thread thr1([&m1, &m2](){
      lock_guard<mutex> lock1(m1);
      lock_guard<mutex> lock2(m2);
   });
   
   thread thr1([&m1, &m2](){
      lock_guard<mutex> lock2(m2);
      lock_guard<mutex> lock1(m1);
   });
   
   thr1.join();
   thr2.join();
}
</code></pre></div>

???
In this example, two threads lock the same two locks, but in reversed order. Lock order inversion
is a recipe for deadlock.

--
count: false
<div class="code_right" style="width: 60%;"><pre><code class="language-bash">
clang++ -std=c++14 -g deadlock.cpp -o deadlock

valgrind --tool=helgrind ./deadlock
</code></pre></div>

???
The program to be analysed is compiled as usual but with debug symbols.
Then the binary is run on Valgrind's synthetic CPU, after the Helgrind tool has added 
instrumentation code to the it.

BRIDGE:
- ThreadSanitizer and Helgrind are very successful and have uncovered many concurrency bugs, 
particularly dataraces, in large applications. 
- However, these tools depend on the error actually being detectable in the execution they 
happended to monitor. These tools do not meet the second challenge that multi-threading poses for 
testing: nondeterminism.

<!-- TODO: Explain how lock inversion analysis works? -->

<!-- <<< -->

<!--
         }
end_subsubsection:Tools -->


<!-- >>> Slide -->

---

```bash
clang++ -std=c++14 -g bank_account.cpp -o bank_account
valgrind --tool=helgrind ./bank_account
```

<!-- <<< -->

---

<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>

--
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
int main()
{
   background_thread_manager m;
   m.run_thread();
   m.run_thread();
   
   m.join_thread();
}
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
main                          m_thread          | m_mutex
                                                |
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == false                    |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                              m_mutex.lock()    | locked
                              // perform task   |
                              m_mutex.unlock()  | unlocked
m_mutex.try_lock()                              | locked
m_thread.joinable() == true                     |
m_thread.join()                                 |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                              m_mutex.lock()    | locked
                              // perform task   |
                              m_mutex.unlock()  | unlocked
m_thread.join()                                 |    
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
main                          m_thread          | m_mutex
                                                |
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == false                    |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == true                     |
                                                |
DEADLOCK:                                       |
m_thread.join()               m_mutex.lock()    |
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---

```bash
clang++ -std=c++14 -g background_thread.cpp -o background_thread
valgrind --tool=helgrind ./background_thread
```

<!-- <<< -->

<!--
            }
end_example:background_thread.cpp -->

<!-- section:Systematic Exploration -->

---

--
count: false
- Buggy schedules are stored so that the bug can be reproduced

<!-- <<< -->

---
exclude: true
# RecordReplay Library
<div class="mermaid" style="align: center; width: 60%; margin: 0px auto;">
   graph LR
      schedule[Schedule<br/><br/>00001111] --> instr_exe[Instrumented Executable]
      instr_exe --> trace[Trace<br/><br/>0 lock mutex</br>0 load x1<br/>0 store x1<br/>0 unlock mutex<br/>1 load x1<br/>1 load x2<br/>1 store x3<br/>1 store x1]
</div></div>

<!-- >>> Slide -->

---
layout: true
#### Systematic Exploration
# Exploration Algorithms

---
<div class="mermaid" style="align: center; width: 80%; margin: 0px auto;">
   graph TD
      exploration[Exploration Algorithm]
      
      exploration --> |00001111| instr_exe1[Instrumented<br/>Executable]
      instr_exe1 --> |trace| exploration
      
      exploration --> |00011110| instr_exe2[Instrumented<br/>Executable]
      instr_exe2 --> |trace| exploration
      
      exploration --> |....| instr_exei[Instrumented<br/>Executable]
      instr_exei --> |trace| exploration
      
      exploration --> |11110000| instr_exen[Instrumented<br/>Executable]
      instr_exen --> |trace| exploration
</div>

<!-- >>> Slide -->







<!-- >>> Slide -->

---
count: false
layout: false
class: slide_section
# Thank you!

<!-- <<< -->

---
layout: true
# References

<!-- >>> Slide -->

---
count: false
### Tools
<span class="h_link">StateSpaceExplorer:</span>
https://github.com/s-vde/state-space-explorer

<span class="h_link">Helgrind:</span>
http://valgrind.org/docs/manual/hg-manual.html

<span class="h_link">ThreadSanitizer:</span>
https://github.com/google/sanitizers/wiki

<br/><br/>
<span class="h_link">CHESS:</span>
https://chesstool.codeplex.com

<span class="h_link">Maple:</span>
https://github.com/jieyu/maple

<!-- <<< -->

<!-- >>> Slide -->

---
count: false
### Selected Literature
C. Flanagan and P. Godefroid (2005),
*Dynamic Partial-Order Reduction for Model Checking Software*,
In: POPL' 05,
pages 110-121
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1040315

P. Godefroid (1997),
*Model Checking for Programming Languages using VeriSoft*,
InL POPL'97,
pages 174-186
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=263717&CFID=824726696&CFTOKEN=68367255

M. Musuvathi and S. Qadeer (2007),
*Iterative Context Bounding for Systematic Testing of Multithreaded Programs*,
In: PLDI' 07,
pages 446-455
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1040315

M. Musuvathi et al. (2008), 
*Finding and Reproducing Heisenbugs in Concurrent Programs*,
In OSDI'08,
pages 267-280
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1855760

<!-- <<< -->





      </textarea>
      
      <script src="../libs/mermaid/dist/mermaid.js"></script>
      <link rel="stylesheet" href="../libs/mermaid/dist/mermaid.forest.css">
      <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
      <script>
         var slideshow = remark.create({ 
            ratio: '16:9',
            highlightLanguage: 'cpp',
            highlightStyle: 'github',
            highlightLines: true
         });
         mermaid.initialize({ 
            startOnLoad: false,
            cloneCssStyles: false
         });
         function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i=0; i < diagrams.length; i++) {
               if(diagrams[i].offsetWidth>0){
                  mermaid.init(undefined, diagrams[i]);
               }
            }
         }
         slideshow.on('afterShowSlide', initMermaid);
         initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);
      </script>
      
   </body>
</html>
