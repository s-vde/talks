<!DOCTYPE html>
<html>
   <head>
      <title>Testing and Verifying Multi-Threaded Programs</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <link rel="stylesheet" type="text/css" href="talk.css"/>
   </head>
   <body>
      <textarea id="source">





<!-- section:Title -->

class: slide_title, no_number
count: false

# Automated Verification of Multi-Threaded Programs
### Susanne van den Elsen
Software Developer @ Native Instruments

### Meeting C++
November 10, 2017

???
Good afternoon, welcome everybody and thank you for coming,
- My name is Susanne van den Elsen and I am a C++ Software Developer @ Native Instruments
- Before joining NI I was doing research @ MPI-SWS
- Research focus: automated software verification
- In one of my projects I specifically looked at automated verification of multi-threaded software
  which is also the topic of my talk today
- In particular, I would like to give an introduction to systematic exploration of multi-threaded
  programs and demonstrate a systematic exploration tool I developed in the context of my research.

<!--
}
end_section:section:Title -->





<!-- section:Challenges in Testing Multi-Threaded Programs
   {
-->

---
class: slide_section, no_number
count: false
layout: false
# Challenges in Testing Multi-Threaded Programs

???
BRIDGE: 
Before I do that, let me first give you an insight in the challenges of testing multi-threaded 
programs and why traditional testing and debugging tools are not sufficient for meeting these 
challenges

<!-- subsection:Concurrency Bugs
      {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs
# Concurrency Bugs

<!-- >>> Slide -->

---

???
First of all, programming with threads instroduces a whole new class of potential bugs to look for.
In general these bugs arise from the fact that multiple threads are sharing the same resources.
In this talk I focus on three types of bugs.


--
count: false
##### Race Conditions
Arise when the program's correctness depends on the relative timing or ordering of thread 
instructions

--
count: false
##### Data Races
Arise when two threads
- access the same memory location concurrently; and 
- at least one of the accesses is a write

???
Data Races:
Since the C++11 memory model we can reason about memory accesses and dataraces are deemed undefined 
behaviour (so it is very important to make sure your programs are datarace free)

--
count: false
##### Deadlocks
Situation where a set of threads is blocked indefinitely because each of them is waiting for 
one of the others to release a held resource

<!-- <<< -->

<!-- subsubsection:Tools
         {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Concurrency Bugs
# Specialized Tools For Concurrency Bug Detection

<!-- >>> Slide -->

---

???
BRIDGE:
- Just like there are tools specifically tailored to detect typical memory errors, concurrency bugs
ask for tools that specialize in detecting them. 
- Luckily there are such tools available, the most well-known ones probably being ThreadSanitizer 
and Helgrind.

--
count: false
##### ThreadSanitizer and Helgrind

<!-- TODO: Am I going to branch off TSan/Helgrind here and explain high-level how they work? -->

--
count: false
- Instrument the program (source vs. binary), run it, and observe its execution
- Deploy algorithms specifically tailored to detect data races (happens-before relation) and deadlocks (cycle detection)
  at run-time
  
<!-- TODO: NOTES -->

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="h_example" style="margin-bottom: 2em;">data_race.cpp</div>
<div class="code_left" style="width: 35%;"><pre><code class="language-cpp">
int main()
{
   int x;
   
   thread thr1([&x](){
      x = 1;
   });
   
   thread thr1([&x](){
      x = 2;
   });
   
   thr1.join();
   thr2.join();
}
</code></pre></div>

<!-- TODO: NOTES -->

--
count: false
<div class="code_right" style="width: 60%;"><pre><code class="language-bash">
clang++ -fsanitize=thread -std=c++14 -g data_race.cpp \
   -o data_race

./data_race
</code></pre></div>

???
Compiling the program to be analyzed with the -fsanitize flag will instrument the program with calls
to the TSan runtime library and link the runtime library to the final executable.

--
exclude: true
<br/>
<img src='./generated_trees/trace_analysis/data_race.png' height="250"/>

<!-- TODO: Explain how the happens-before data race detection works? -->

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="h_example" style="margin-bottom: 2em;">deadlock.cpp</div>
<div class="code_left" style="width: 35%;"><pre><code class="language-cpp">
int main()
{
   mutex m1, m2;
   
   thread thr1([&m1, &m2](){
      lock_guard<mutex> lock1(m1);
      lock_guard<mutex> lock2(m2);
   });
   
   thread thr1([&m1, &m2](){
      lock_guard<mutex> lock2(m2);
      lock_guard<mutex> lock1(m1);
   });
   
   thr1.join();
   thr2.join();
}
</code></pre></div>

???
In this example, two threads lock the same two locks, but in reversed order. Lock order inversion
is a recipe for deadlock.

--
count: false
<div class="code_right" style="width: 60%;"><pre><code class="language-bash">
clang++ -std=c++14 -g deadlock.cpp -o deadlock

valgrind --tool=helgrind ./deadlock
</code></pre></div>

???
The program to be analysed is compiled as usual but with debug symbols.
Then the binary is run on Valgrind's synthetic CPU, after the Helgrind tool has added 
instrumentation code to the it.

BRIDGE:
- ThreadSanitizer and Helgrind are very successful and have uncovered many concurrency bugs, 
particularly dataraces, in large applications. 
- However, these tools depend on the error actually being detectable in the execution they 
happended to monitor. These tools do not meet the second challenge that multi-threading poses for 
testing: nondeterminism.

<!-- TODO: Explain how lock inversion analysis works? -->

<!-- <<< -->

<!--
         }
end_subsubsection:Tools -->

<!-- subsection:Nondeterminism
      {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs
# Nondeterminism

<!-- >>> Slide -->

---

???
Multi-threading introduces a very specific layer of nondeterminism to a program.

--
count: false
##### OS Scheduler Policy
The order in which threads get to execute at runtime is under the control of the OS scheduler.

???
The scheduler in turn can make its choices based on execution enviroment

--
count: false
##### Execution Environment
e.g.

--
count: false
- Current CPU load

--
count: false
- Priorities of other threads on the CPU

--
count: false
- State of the cache

???
E.g. is the current thread slowed down by cache misses

<!-- TODO: slide -->
- The total order on which the threads operate on shared data often has an influence the program's 
outcome
-->

<!-- <<< -->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Nondeterminism
# What does this mean for testing?

<!-- >>> Slide -->

---

--
count: false
##### Hard to get good test coverage:
- Running tests repeatedly without the guarantee that schedules will be different

--
count: false
- Some bugs only occur under very rare schedules
<!-- Approach of inducing bad schedules by forcing context-switches is not systematic! -->

--
count: false
- "Heisenbugs" may even disappear as a result of changes in timing introduced by the debugging tool
<!-- bugs that tend to disappear when you want to find them -->

--
count: false
##### Bugs are hard to reproduce: 
- If buggy behavior is observed, the next execution may be under a different schedule

<!-- <<< -->

???
BRIDGE:
Let's look at two small example programs that demonstrate the challenge of nondeterminism for 
testing. These programs will later be used to demonstrate systematic exploration.
-->

<!-- example:bank_account.cpp
            {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Nondeterminism
# Example: bank_account.cpp


<!-- >>> Slide -->

---

```cpp
struct bank_account { atomic<int> balance; }

void transfer(bank_account& from, int amount, bank_account& to);
```

???
A bank account has a balance and there is a function for transferring a given amount of money from
one bank account to the other.
Specification of the program is that after every transfer, a balance is positive.

--
count: false
```cpp
TEST(BalancesArePositive)
{
   array<bank_account, 2> accounts = {{ 100, 0 }};
   thread mallory(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   thread marvin(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   
   mallory.join();
   marvin.join();
   
   ASSERT(all_of(accounts.begin(), accounts.end(), [](auto balance){ positive(balance); }));
}
```

???
This is the test case that check this assertion.
- There are two accounts, one with an initial balance of 100, and one with an initial balance of 0
- Two adversary threads, Mallory and Marvin both try to transfer 100 euros from the first to the 
  second account.
- Obviously, if the program meets the specification, at least one of them should not succeed
- The assertion states that after both threads are joined, both accounts have positive balance.

<!-- <<< -->

<!-- >>> Slide -->

---

```cpp
struct bank_account { atomic<int> balance; }

void transfer(bank_account& from, int amount, bank_account& to)
{
   const auto balance_from = from.balance.load();
   if (balance_from >= amount)
   {
      to.balance.fetch_add(amount);
      from.balance.fetch_sub(amount);
   }
}
```

???
Here is an *attempt* at an implementation of the bank account.
1. atomically read the balance of the sender's account1
2. check if the balance is sufficient for transfering the given amount of money out of it 
3. if so, atomically add the amount to the receiver's account and subsequently subtract the same 
amount from the sender's account.

--
count: false
```cpp
mallory                                      marvin                                       accounts

balance_from = from.balance.load() = 100;                                                 { 100,  0   }
to.balance.fetch_add(amount);                                                             { 100,  100 }
from.balance.fetch_sub(amount);                                                           { 0,    100 }
                                             balance_from = from.balance.load() = 0;      { 0,    100 }
```

--
count: false
```cpp
// assertion holds :)
ASSERT(all_of(accounts.begin(), accounts.end(), [](auto balance){ positive(balance); }));
```

<!-- <<< -->

<!-- >>> Slide -->

---

```cpp
struct bank_account { atomic<int> balance; }

void transfer(bank_account& from, int amount, bank_account& to)
{
   const auto balance_from = from.balance.load();
   if (balance_from >= amount)
   {
      to.balance.fetch_add(amount);
      from.balance.fetch_sub(amount);
   }
}
```

```cpp
mallory                                      marvin                                       accounts

balance_from = from.balance.load() = 100;                                                 { 100,  0   }
                                             balance_from = from.balance.load() = 100;    { 100,  0   }
                                             to.balance.fetch_add(amount);                { 100,  100 }
                                             from.balance.fetch_sub(amount);              { 0,    100 }
to.balance.fetch_add(amount);                                                             { 0,    200 }
from.balance.fetch_sub(amount);                                                           { -100, 200 }         

```

--
count: false
```cpp
// assertion is violated :(!
ASSERT(all_of(accounts.begin(), accounts.end(), [](auto balance){ positive(balance); }));
```

<!-- <<< -->

<!-- >>> Slide -->

---

```bash
clang++ -std=c++14 -g bank_account.cpp -o bank_account
valgrind --tool=helgrind ./bank_account
```

<!-- <<< -->

<!--
            }
end_example:bank_account.cpp -->

<!-- example:background_thread.cpp
            {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Nondeterminism
# Example: background_thread.cpp

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>

--
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
int main()
{
   background_thread_manager m;
   m.run_thread();
   m.run_thread();
   
   m.join_thread();
}
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
main                          m_thread          | m_mutex
                                                |
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == false                    |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                              m_mutex.lock()    | locked
                              // perform task   |
                              m_mutex.unlock()  | unlocked
m_mutex.try_lock()                              | locked
m_thread.joinable() == true                     |
m_thread.join()                                 |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                              m_mutex.lock()    | locked
                              // perform task   |
                              m_mutex.unlock()  | unlocked
m_thread.join()                                 |    
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
main                          m_thread          | m_mutex
                                                |
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == false                    |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == true                     |
                                                |
DEADLOCK:                                       |
m_thread.join()               m_mutex.lock()    |
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---

```bash
clang++ -std=c++14 -g background_thread.cpp -o background_thread
valgrind --tool=helgrind ./background_thread
```

<!-- <<< -->

<!--
            }
end_example:background_thread.cpp -->

<!--
      }
end_subsubsection:Nondeterminism -->

<!--
}
end_section:section:Challenges in Testing Multi-Threaded Programs -->





<!-- section:Systematic Exploration -->

---

--
count: false
- Buggy schedules are stored so that the bug can be reproduced

<!-- <<< -->

---
exclude: true
# RecordReplay Library
<div class="mermaid" style="align: center; width: 60%; margin: 0px auto;">
   graph LR
      schedule[Schedule<br/><br/>00001111] --> instr_exe[Instrumented Executable]
      instr_exe --> trace[Trace<br/><br/>0 lock mutex</br>0 load x1<br/>0 store x1<br/>0 unlock mutex<br/>1 load x1<br/>1 load x2<br/>1 store x3<br/>1 store x1]
</div></div>

<!-- >>> Slide -->

---
layout: true
#### Systematic Exploration
# Exploration Algorithms

---
<div class="mermaid" style="align: center; width: 80%; margin: 0px auto;">
   graph TD
      exploration[Exploration Algorithm]
      
      exploration --> |00001111| instr_exe1[Instrumented<br/>Executable]
      instr_exe1 --> |trace| exploration
      
      exploration --> |00011110| instr_exe2[Instrumented<br/>Executable]
      instr_exe2 --> |trace| exploration
      
      exploration --> |....| instr_exei[Instrumented<br/>Executable]
      instr_exei --> |trace| exploration
      
      exploration --> |11110000| instr_exen[Instrumented<br/>Executable]
      instr_exen --> |trace| exploration
</div>

<!-- >>> Slide -->







<!-- >>> Slide -->

---
count: false
layout: false
class: slide_section
# Thank you!

<!-- <<< -->

---
layout: true
# References

<!-- >>> Slide -->

---
count: false
### Tools
<span class="h_link">StateSpaceExplorer:</span>
https://github.com/s-vde/state-space-explorer

<span class="h_link">Helgrind:</span>
http://valgrind.org/docs/manual/hg-manual.html

<span class="h_link">ThreadSanitizer:</span>
https://github.com/google/sanitizers/wiki

<br/><br/>
<span class="h_link">CHESS:</span>
https://chesstool.codeplex.com

<span class="h_link">Maple:</span>
https://github.com/jieyu/maple

<!-- <<< -->

<!-- >>> Slide -->

---
count: false
### Selected Literature
C. Flanagan and P. Godefroid (2005),
*Dynamic Partial-Order Reduction for Model Checking Software*,
In: POPL' 05,
pages 110-121
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1040315

P. Godefroid (1997),
*Model Checking for Programming Languages using VeriSoft*,
InL POPL'97,
pages 174-186
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=263717&CFID=824726696&CFTOKEN=68367255

M. Musuvathi and S. Qadeer (2007),
*Iterative Context Bounding for Systematic Testing of Multithreaded Programs*,
In: PLDI' 07,
pages 446-455
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1040315

M. Musuvathi et al. (2008), 
*Finding and Reproducing Heisenbugs in Concurrent Programs*,
In OSDI'08,
pages 267-280
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1855760

<!-- <<< -->





      </textarea>
      
      <script src="../libs/mermaid/dist/mermaid.js"></script>
      <link rel="stylesheet" href="../libs/mermaid/dist/mermaid.forest.css">
      <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
      <script>
         var slideshow = remark.create({ 
            ratio: '16:9',
            highlightLanguage: 'cpp',
            highlightStyle: 'github',
            highlightLines: true
         });
         mermaid.initialize({ 
            startOnLoad: false,
            cloneCssStyles: false
         });
         function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i=0; i < diagrams.length; i++) {
               if(diagrams[i].offsetWidth>0){
                  mermaid.init(undefined, diagrams[i]);
               }
            }
         }
         slideshow.on('afterShowSlide', initMermaid);
         initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);
      </script>
      
   </body>
</html>
