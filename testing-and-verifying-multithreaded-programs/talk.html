<!DOCTYPE html>
<html>
   <head>
      <title>Testing and Verifying Multi-Threaded Programs</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <link rel="stylesheet" type="text/css" href="talk.css"/>
   </head>
   <body>
      <textarea id="source">



class: center, middle

<!-- =============================================================================================================== -->
<!--- section:TITLE -->

# Verifying Multi-Threaded Programs Using Dynamic Analysis
### Susanne van den Elsen
Software Developer @ Native Instruments

### Meeting C++
November 10, 2017



<!-- =============================================================================================================== -->
<!--- section:Multi-Threading at Native Instruments -->

---
exclude: true
# Multi-Threading at Native Instruments

<!-- links
-   http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing
-->


<!-- =============================================================================================================== -->
<!-- section:Challenges in Testing and Verifying Multi-Threaded Programs -->

---
layout: true
# Challenges in Testing and Verifying Multi-Threaded Programs

---

<!-- subsection:Concurrency Bugs -->

---
layout: true
#### Challenges in Testing and Verifying Multi-Threaded Programs
# Concurrency Bugs

---

--
count: false
- Arise from multiple threads sharing resources

<!-- subsubsection:Race Conditions -->

---
layout: true
#### Challenges in Testing and Verifying Multi-Threaded Programs | Concurrency Bugs
# Race Conditions

---
Arise when the program's correctness depends on the relative timing or ordering of thread 
instructions

---
```cpp
transfer(account& from, int amount, account& to)
{
   const auto balance_from = from.balance.load();
   if (balance_from >= amount)
   {
      to.balance.fetch_add(amount);
      from.balance.fetch_sub(amount);
   }
}

TEST(BalancesArePositive)
{
   array<atomic<int>, 2> accounts = {{ 100, 0 }};
   thread mallory(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   thread marvin(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   
   mallory.join();
   marvin.join();
   
   ASSERT(all_of(accounts.begin(), accounts.end(), [](auto balance){ positive(balance); }));
}
```

---
```cpp
mallory                                      marvin                                       accounts

balance_from = from.balance.load() = 100;                                                 { 100,  0   }
                                             balance_from = from.balance.load() = 100;    { 100,  0   }
to.balance.fetch_add(amount);                                                             { 100,  100 }
from.balance.fetch_sub(amount);                                                           { 0,    100 }         
                                             to.balance.fetch_add(amount);                { 0,    200 }
                                             from.balance.fetch_sub(amount);              { -100, 200 }
```

<!-- subsubsection:Data Races -->

---
layout: true
#### Challenges in Testing and Verifying Multi-Threaded Programs | Concurrency Bugs
# Data Races

---
Arise when two threads 
- may access the same memory location concurrently; and 
- at least one of the accesses is a write

--
count: false
*memory location:* since the c++11 memory model we can reason about memory accesses

--
count: false
*may access concurrently:* accesses are not ordered by the *happens-before relation*

--
count: false
Data races are **Undefined Behaviour!**

---
```cpp
int x, y, z = 0;

int main()
{
   thread t1([]{
      if (x == 1)
         y = 1;
   });
   
   thread t2([]{
      x = 1;
      z = x + y;
   });
}                                   
```

---
```cpp
t1                   t2             x,    y,    z

x == 1?                             0,    0,    0
                     x = 1          1,    0,    0
                     read y         1,    0,    0 
                     z = x + y      1,    0,    1
```

--
count: false
```cpp
t1                   t2             x,    y,    z

                     x = 1          1,    0,    0
x == 1?                             1,    0,    0
y = 1                               1,    1,    0
                     read y         1,    1,    0 
                     z = x + y      1,    1,    2                                   
```

<!-- subsubsection:Deadlocks -->

---
layout: true
#### Challenges in Testing and Verifying Multi-Threaded Programs | Concurrency Bugs
# Deadlocks

---
Two or more threads wait for each other indefinitely

---
```cpp
struct background_thread_manager
{
   void cancel() {
      if (m_background_thread.joinable())
         m_background_thread.join();
   }
   
   void run_thread() {
      if (m_mutex.try_lock()) {        // no background_thread already running
         cancel();
      
         m_background_thread([this]() {            
            m_mutex.lock();
            // ... perform task ...
            m_mutex.unlock();
         });
      
         m_mutex.unlock();             // only now m_background_thread can perform task
      }
   }
   
   thread m_background_thread;
   mutex m_mutex;
};
```

---
```cpp
struct background_thread_manager                         int main()
{                                                        {
   void cancel() {                                          background_thread_manager m;
      if (m_background_thread.joinable())                   m.run_thread();
         m_background_thread.join();                        this_thread::sleep_for(1s);
   }                                                        m.run_thread();
                                                            
   void run_thread() {                                      m.cancel();
      if (m_mutex.try_lock()) {                          }
         cancel();
      
         m_background_thread([this]() {            
            m_mutex.lock();
            // ... perform task ...
            m_mutex.unlock();
         });
      
         m_mutex.unlock();
      }
   }
   
   thread m_background_thread;
   mutex m_mutex;
};
```

---
```cpp
main                                   m_background_thread        m_mutex
                                 
run_thread();                                                     unlocked
   m_mutex.try_lock();                                            locked
   cancel();            
      m_background_thread.joinable()?  // not joinable
   spawn m_background_thread           // becomes joinable
   m_mutex.unlock();                                              unlocked

this_thread::sleep_for(1s);

run_thread();      
   m_mutex.try_lock();                                            locked
   cancel();
      m_background_thread.joinable()?
      m_background_thread.join();      // not joinable
                                       m_mutex.lock(); // blocked
```

---
layout: true
#### Challenges in Testing and Verifying Multi-Threaded Programs | Concurrency Bugs
# Specialized Tools For Concurrency Bug Detection

---
*State-Of-The-Art Examples:* ThreadSanitizer and Helgrind
- Instrument the program (source vs. binary), run it, and observe its execution
- Deploy algorithms specifically tailored to detect data races (happens-before relation) and deadlocks (cycle detection)
  at run-time

<!-- links
-   https://github.com/google/sanitizers
-   http://valgrind.org/docs/manual/hg-manual.html
-->

<!-- subsection:Nondeterminism -->

---
layout: true
#### Challenges in Testing and Verifying Multi-Threaded Programs
# Nondeterminism

---

--
count: false
- Single-threaded programs have nondeterminism for example from user input or randomization
- Multi-threaded programs have another level of nondeterminism
- Program specifies only *partial order* on the instructions performed by different threads (e.g. by atomics
  and memory order constraints and by locks / condition variables)
- The total order of instructions becoming visible is outsourced to the OS scheduler and the processor.

---
### What does this mean for testing?
- Heisenbugs: Bugs that tend to disappear when you want to find them (e.g. does not appear when compiled without
  optimization, as often done for debuggers, or changes in timing when ran under control of a debugger)
- Rare schedules: Bugs that only occur under very rare schedules
- Coverage: Running tests repeatedly without guarantee that schedules will be different
- Coverage: Inducing bad schedules by forcing context-switches, but not systematic
- Reproducibility: If buggy behavior is observed, not easy to reproduce

---
### Demo: Helgrind on background_thread



<!-- =============================================================================================================== -->
<!-- section:Systematic Exploration of Program Behavior -->

---
layout: true
# Systematic Exploration

---

---
layout: true
#### Systematic Exploration

---

--
count: false
- Test cases are schedules
- Take control over the interleaving of threads: 
    - Instrument system under test using LLVM compiler pass with hooks to be used by a custom scheduler;
        * Instrument *every* memory access
        * Instrument thread creation, joining, entering/leaving a function
    - Scheduler records the runtime interleaving of the system under test;
    - Scheduler can replay the system under test under any *valid* input thread interleaving.
        * High-level implementation: semaphore for each thread, at any point in time all but one thread are blocked
          on their semaphore
        * Underlying OS is forced to schedule the thread that is no blocked.
- A search algorithm driving the system under test through interesting interleavings.

---
# RecordReplay Library
<div class="mermaid" style="align: center; width: 60%; margin: 0px auto;">
   graph TD
      sut[Souce Code] --> |Clang| ir[LLVM IR]
      ir --> |RecordReplay Instrumentation Pass| instr_ir[Instrumented IR]
      scheduler[Run Time Scheduler Library]
      instr_exe[Instrumented Executable]
      instr_ir --> instr_exe
      scheduler --> instr_exe
</div></div>

---
# RecordReplay Library
<div class="mermaid" style="align: center; width: 60%; margin: 0px auto;">
   graph LR
      schedule[Schedule<br/><br/>00001111] --> instr_exe[Instrumented Executable]
      instr_exe --> trace[Trace<br/><br/>0 lock mutex</br>0 load x1<br/>0 store x1<br/>0 unlock mutex<br/>1 load x1<br/>1 load x2<br/>1 store x3<br/>1 store x1]
</div></div>

<!-- Notes:
LLVM IR: low-level assembly-like language that is designed so that many higher level langauges
         can be mapped to it;
-->

---
# StateSpaceExplorer
<div class="mermaid" style="align: center; width: 80%; margin: 0px auto;">
   graph TD
      exploration[Exploration Algorithm]
      
      exploration --> |00001111| instr_exe1[Instrumented<br/>Executable]
      instr_exe1 --> |trace| exploration
      
      exploration --> |00011110| instr_exe2[Instrumented<br/>Executable]
      instr_exe2 --> |trace| exploration
      
      exploration --> |....| instr_exei[Instrumented<br/>Executable]
      instr_exei --> |trace| exploration
      
      exploration --> |11110000| instr_exen[Instrumented<br/>Executable]
      instr_exen --> |trace| exploration
</div></div>

<!-- subsection:Exploration Algorithms -->

---
layout: true
#### Systematic Exploration
# Exploration Algorithms

---

---
layout: true
#### Systematic Exploration - Exploration Algorithms

<!-- subsubsection:Depth-First Exploration -->

---
# Depth-First Exploration

--
count: false
*pseudocode:*
```cpp
depth_first_exploration(program)
{
   for (schedule : possible_schedules(program))
   {
      run(program, schedule);
   }
}
```

<!-- TODO: state-space explosion tree -->

---
# Combinatorial Explosion!

--
count: false
*Problem:* The number of possible thread interleavings grows exponentially with the size of the program!

--
count: false
*Solution:* Prune the state-space

--
count: false
*Challenge:* Coverage Guaranteees

<!-- subsection:Bounded Search -->

---
layout: true
#### Systematic Exploration - Exploration Algorithms
# Bounded Exploration

---

--
count: false
*bound function:* a function on schedules (e.g. length, number of context-switches, number of preemptions)

--
count: false
*bound value:*

--
count: false
*pseudocode:*
```cpp
bounded_exploration(program, bound_function, bound_value)
{
   for (schedule : possible_schedules(program))
   {
      if (bound_function(schedule) <= bound_value)
      {
         run(program, schedule);
      }
   }
}
```

<!-- TODO: example run -->

---
- Empirically, many bugs in concurrent software manifest are exposed by SOME schedule with small number of context
  switches/preemptions (TODO: citation)
- Already notion of different schedules leading to same behavior, some with high, some with low depth.
- Complexity: program with n threads that each execute at most k steps: O(n^(2c)k^c) schedules with c context-switches.
    polynomial in k, for fixed context-bound
- But: May still explore many schedules that lead to *semantically* equivalent program executions.

<!-- citations
-   S. Qadeer and J. Rehof. 
    Context-bounded model checking of concurrent software. 
    In TACAS 05: Tools and Algorithms for the Construction and Analysis of Systems,
    volume 3440 of Lecture Notes in Computer Science, pages 93–107. Springer, 2005
-->

<!-- subsection:Partial Order Reduction -->

---
layout: true
#### Systematic Exploration - Exploration Algorithms
# Partial Order Reduction

---

--
count: false
*equivalence relation:* groups schedules that lead to the same observable program behaviour

--
count: false
*pseudocode:*
```cpp
partial_order_reduction(program)
{
   for (equivalence_class : equivalence_classes(program))
   {
      schedule = representative(equivalence_class);
      run(program, schedule);
   }
}
```

---
- Complete: explore at least one schedule per equivalence class;
- Ideally explore a single trace/schedule per equivalence class



<!-- =============================================================================================================== -->
<!-- section:References -->

---
layout: true
# References

---
TODO


---
layout: false

<!-- =============================================================================================================== -->
<!-- notes:
* Many tools available for testing / verifying sequential code (that is hard enough already!);
* Tool still in progress: not full support of C++11 memory model (e.g. visible sequences of side effects, atomics).

* Even though we see a tendency towards more and more high-level concurrency constructs (e.g. futures, coroutines) and 
programmers are more and more discouraged to use std::thread, and std::mutex, which become implementation details, there 
are domains where exactly these implementation details still matter (e.g. realtime systems, cyberphysical systems).
* Other examples such as CppMem (http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/).
* Runtime nature of the tool, but can still prove completeness of the exploration tree (e.q. using Coq).
* Something about the implementation details, i.e. vector clocks?


* Difference between software testing and software verification;
* General limitations of software verification and dynamic verification, e.g. non-halting programs excluded;
* Verification w.r.t. a *class* of bugs/errors, a specification (e.g. Datarace free);
* Difference between static analysis and dynamic analysis (e.g. examples from Flanagan/Godefroid).

section:Concurrency and Concurrency Errors 
- Test input is a program and a schedule, observation is execution/trace and execution result
- Difficult to reason about the interaction of threads

* Think about examples:
    - background_thread
    - workstealing_queue
    - double_instance
    - Depth-bounding examples from the paper, showing that empirically, many bugs have small depth
    - Example with large depth
    - Example where POR and optimal POR differ a lot
-->

<!--- section:CONCURRENCY_HARD -->

---
exclude: true
# What's Hard About Concurrency?
### Synchronisation

```cpp
array<int,2> nr_meals_eaten = {0, 0};
mutex fork1, fork2;

philosopher 0              philosopher 1
-------------              -------------

lock(fork1);               lock(fork2);
lock(fork2);               lock(fork1);
++nr_meals_eaten[0];       ++nr_meals_eaten[1];
unlock(fork2);             unlock(fork1);
unlock(fork1);             unlock(fork2);
```

---
exclude: true
# What's Hard About Concurrency?
### Synchronisation

```cpp
array<int,2> nr_meals_eaten = {0, 0};
mutex fork1, fork2;

philosopher 0              philosopher 1
-------------              -------------

lock(fork1);               
                           lock(fork2);
lock(fork2);               
                           lock(fork1);
++nr_meals_eaten[0];       ++nr_meals_eaten[1];
unlock(fork2);             unlock(fork1);
unlock(fork1);             unlock(fork2);
```

---
count: false
# What's Hard About Concurrency?
### State Space Explosion
Number of possible thread interleavings is *exponential* in the number of threads and instructions!
<br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

---
# What's Hard About Concurrency?
### Nondeterminism

The interleaving of threads is out of the programmer's control
<br/><br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

---
count: false
# What's Hard About Concurrency?
### Nondeterminism

The interleaving of threads is out of the programmer's control
<br/><br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion_buggy.jpg' width="800"/>]

???
It may depend on 
- load on the maschine 
- OS scheduler strategy

---
count: false
# What's Hard About Concurrency?
### Nondeterminism

The interleaving of threads is out of the programmer's control
<br/><br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion_good.jpg' width="800"/>]

<!--- section:CONCURRENCY_ERROR_DETECTORS -->

---
class: center, middle
# Concurrency Error Detectors

---
# Concurrency Error Detectors
### ThreadSanitzer
```shell
clang++ program_under_test.cpp -fsanitize=thread -o program_under_test
./program_under_test
```
--
count: false
#### Compiler Instrumentation (LLVM IR)

Instrument every potentially *visible* instruction (e.g. `load`, `store`)
--
count: false
```
define void @function() {
__tsan_func_entry(caller)
%2 = alloca i32
__tsan_store(%2)
store i32 %0, i32* %2
__tsan_load(%2)
%4 = load i32, i32* %2
ret i32 %4
__tsan_func_exit()
}
```

---
count: false
# Concurrency Error Detectors
### ThreadSanitzer
#### Runtime library
The `__tsan_` functions are callbacks to a Runtime Library (part of clang-rt)

Maintains a state maschine using shadow state for analysis

---
# Concurrency Error Detectors
### Helgrind
#### Binary Instrumentation
```shell
valgrind --tool=helgrind -v program
```

- Program is run on synthetic CPU provided by Valgrind Core 
- Threads are fully serialzed (only single CPU used)

---
# ThreadSanitizer & Helgrind: Data Races
<br/><br/>
<tr>
    <td><img src="./images/jpg/tsan_data-race-no-locks-hb.jpg" style="height: 300px;"/></td>
    <td><img src="./images/jpg/shadow_state_x.001.jpeg" style="height: 300px;"/></td>
</tr>

---
# ThreadSanitizer & Helgrind: Data Races
Using the *happens-before* relation:
<br/><br/>
<tr>
    <td><img src='./images/jpg/tsan_data-race-locks-hb-1.jpg' height="400"/></td>
</tr>
.center[]

---
count: false
# ThreadSanitizer & Helgrind: Data Races
Using the *happens-before* relation:
<br/><br/>
<tr>
    <td><img src='./images/jpg/tsan_data-race-locks-hb-2.jpg' height="400"/></td>
</tr>

---
count: false
# ThreadSanitizer & Helgrind: Data Races
Using the *happens-before* relation:
<br/><br/>
<tr>
    <td><img src='./images/jpg/tsan_data-race-locks-hb-3.jpg' height="400"/></td>
    <td><img src="./images/jpg/shadow_state_x.002.jpeg" style="height: 400px;"/></td>
</tr>

???
When a mutex is unlocked by thread T1 and later (or immediately) locked by thread T2, 
then the memory accesses in T1 prior to the unlock must happen-before those in T2 after 
it acquires the lock.

---
# ThreadSanitizer & Helgrind: Data Races
Limited information in *single* execution:
<br/><br/><br/>
.center[<img src='./images/jpg/tsan_data-race-branch-hb.jpg' height="375"/>]

---
# ThreadSanitizer: Deadlock
<img src='./images/jpg/tsan_deadlock.jpeg' height="500"/>

---
class: middle, center
# Systematic Exploration

---
# Systematic Exploration
<br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

<!--- section:SYSTEMATIC_EXPLORATION -->

---
# Taking Control Over the Thread Interleavings
#### LLVM IR Instumentation Pass

Replace 
```cpp
pthread_create(pid, attr, start_routine, args)
pthread_join(pid)
``` 
by 
```cpp 
wrapper_spawn_thread(pid, attr, start_routine, args)
wrapper_pthread_join()
```

#### Scheduler
```cpp
void wrapper_spawn_thread(pid, attr, start_routine, args)
{
   semaphores.insert({ pid, semaphore() })
   pthread_create(pid, attr, start_routine, args)
}
```

---
count: false
# Taking Control Over the Thread Interleavings
#### LLVM IR Instumentation Pass

Insert call to potentially *visible* instructions
```
wrap_post_task(instruction(store, %2, is_atomic))
store i32 %0, i32* %2
```

#### Scheduler
```cpp
void wrapper_post_task(instruction)
{
   task_pool.insert({ this_thread::id(), instruction });
   semaphores[this_thread::id()].wait();
   // wait for turn
   
   task_pool.remove(this_thread::id());
   // perform instructions
}
```

---
count: false
# Taking Control Over the Thread Interleavings
#### Scheduler

```cpp
void scheduler_thread(schedule)
{
   for (thread_id : schedule)
   {
      wait_until(task_pool.contains_key(thread_id));
      current_thread_id = thread_id;
      semaphore[thread_id].post();
      // notify the waiting thread
   }
}
```

---
# Systematic Exploration
### Simple depth-first exploration
State space explosion: becomes infeasible for larger programs
<br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

---
# State Space Reduction
- Explore only a subset of interleavings
- Provide coverage guarantees: quantify the class / number of interleavings seen

--
count: zero
### Bound Functions
- Number of context-switches
- Number of preemptions

---
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-1.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-1-no-1.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-1-no-2.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-2.jpg' height="550"/>]

---
##### Bounded Search with Preemption Bound = 1
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-1-1.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 1
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-1-2.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 1
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-1-3.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 1
<br/><br/><br/><br/><br/>
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-all-preemptions-1.jpg' width="750"/>]

---
# Bounded Search

### Advantages:
- Very fast for low bounds
- Quantifiable coverage
- Incremental

### Disadvantages:
- Incomplete
- For high bounds not better than depth first search

---
# Partial Order Reduction

Different interleavings may yield *equivalent* executions:
Ideally explore only a single one of those

--
count: false
#### Dependence Relation

```cpp
bool dependent(memory_instr1, memory_instr2)
{
   return same_thread(memory_instr1, memory_instr2) || 
          ( same_operand(memory_instr1, memory_instr2) &&
            memory_instr1.is_write() || memory_inst2.is_write() );
}
```
```cpp
bool dependent(lock_instr1, lock_instr2)
{
   return same_thread(lock_instr1, lock_instr2) || 
          ( same_operand(lock_instr1, lock_instr2) &&
            lock_instr1.is_lock() && lock_inst2.is_lock() );
}
```

---
# Partial Order Reduction 

<br/>
<tr>
    <td><img src='./images/jpg/happens_before_equivalence_class_1.jpg' width="350"/></td>
    <td><img src="./images/jpg/happens_before_equivalence_class_2.jpg" width="350"/></td>
</tr>

---
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_1.jpg' width="550"/>]

---
count: false
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_2.jpg' width="750"/>]
---
count: false
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_3.jpg' width="750"/>]

---
count: false
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_4.jpg' width="750"/>]

---
# Partial Order Reduction

### Advantages:
- Complete coverage

### Disadvantages:
- Still infeasible for large state-spaces with many dependencies
- Not incremental

---
class: center, middle
# Thank you!

<!-- section:LINKS -->

---
# Links

#### Helgrind
http://valgrind.org/docs/manual/hg-manual.html

#### ThreadSanitizer:
https://github.com/google/sanitizers/wiki

#### My Project:
https://github.com/s-vde/record-replay

https://github.com/s-vde/state-space-explorer



      </textarea>
      
      <script src="../libs/mermaid/dist/mermaid.js"></script>
      <link rel="stylesheet" href="../libs/mermaid/dist/mermaid.forest.css">
      <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
      <script>
         var slideshow = remark.create({ 
            ratio: '16:9' 
         });
         mermaid.initialize({ 
            startOnLoad: false,
            cloneCssStyles: false
         });
         function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i=0; i < diagrams.length; i++) {
               if(diagrams[i].offsetWidth>0){
                  mermaid.init(undefined, diagrams[i]);
               }
            }
         }
         slideshow.on('afterShowSlide', initMermaid);
         initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);
      </script>
      
   </body>
</html>
