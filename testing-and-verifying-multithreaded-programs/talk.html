<!DOCTYPE html>
<html>
   <head>
      <title>Testing and Verifying Multi-Threaded Programs</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <link rel="stylesheet" type="text/css" href="talk.css"/>
   </head>
   <body>
      <textarea id="source">



class: center, middle

<!-- =============================================================================================================== -->
<!--- section:TITLE -->

# Verifying Multi-Threaded Programs Using Dynamic Analysis
### Susanne van den Elsen
Software Developer @ Native Instruments

### Meeting C++
November 10, 2017



<!-- =============================================================================================================== -->
<!--- section:Multi-Threading at Native Instruments -->

---
# Multi-Threading at Native Instruments

<!-- links
-   http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing
-->


<!-- =============================================================================================================== -->
<!-- section:Challenges in Testing and Verifying Multi-Threaded Programs -->

---
layout: true
# Challenges in Testing and Verifying Multi-Threaded Programs

---

<!-- subsection:Concurrency Bugs -->

---
## Concurrency Bugs

--
- Arise from multiple threads sharing resources

---
## Concurrency Bugs
### Race Conditions

---
## Concurrency Bugs
### Data Races
- Definition
- Reason about memory since C++11 memory model
- Since then: undefined behavior!

---
## Concurrency Bugs
### Deadlocks

---
## Concurrency Bugs
### Livelocks

---
## Concurrency Bugs
- Need specialized tools that catch these kind of bugs
- Trace Analysis for concurrency error *detection*: e.g. ThreadSanitizer and Helgrind
- Instrument the program (source vs. binary) and observe its execution
- Deploy algorithms specifically tailored to detect data races (happens-before relation) and deadlocks (cycle detection)
  at run-time

<!-- links
-   https://github.com/google/sanitizers
-   http://valgrind.org/docs/manual/hg-manual.html
-->

<!-- subsection:Nondeterminism -->

---
## Nondeterminism
- Single-threaded programs have nondeterminism for example from user input or randomization
- Multi-threaded programs have another level of nondeterminism
- Program specifies only *partial order* on the instructions performed by different threads (e.g. by atomics
  and memory order constraints and by locks / condition variables)
- The total order of instructions becoming visible is outsourced to the OS scheduler and the processor.

---
## Nondeterminism
### What does this mean for testing?
- Heisenbugs: Bugs that tend to disappear when you want to find them (e.g. does not appear when compiled without
  optimization, as often done for debuggers, or changes in timing when ran under control of a debugger)
- Rare schedules: Bugs that only occur under very rare schedules
- Coverage: Running tests repeatedly without guarantee that schedules will be different
- Coverage: Inducing bad schedules by forcing context-switches, but not systematic
- Reproducibility: If buggy behavior is observed, not easy to reproduce

---
## Nondeterminism
### Demo: Helgrind on background_thread



<!-- =============================================================================================================== -->
<!-- section:Systematic Exploration of Program Behavior -->

---
layout: true
# Systematic Exploration

---
--
- Insight: Test cases are schedules
- Take control over the interleaving of threads: 
    - Instrument system under test using LLVM compiler pass with hooks to be used by a custom scheduler;
        * Instrument *every* memory access
        * Instrument thread creation, joining, entering/leaving a function
    - Scheduler records the runtime interleaving of the system under test;
    - Scheduler can replay the system under test under any *valid* input thread interleaving.
        * High-level implementation: semaphore for each thread, at any point in time all but one thread are blocked
          on their semaphore
        * Underlying OS is forced to schedule the thread that is no blocked.
- A search algorithm driving the system under test through interesting interleavings.

---
<div style="padding-top: 1em;">
<div class="mermaid" style="align: left; width: 100%; margin: 0px auto;">
   graph TD;
      exploration[Exploration Algorithm];
      
      exploration --> |00001111| instr_exe1[Executable];
      instr_exe1 --> |trace| exploration;
      
      exploration --> |00011110| instr_exe2[Executable];
      instr_exe2 --> |trace| exploration;
      
      exploration --> |....| instr_exei[Executable];
      instr_exei --> |trace| exploration;
      
      exploration --> |11110000| instr_exen[Executable];
      instr_exen --> |trace| exploration;
</div></div>

---
<div style="padding-top: 1em;">
<div class="mermaid" style="align: left; width: 100%; margin: 0px auto;">
   graph TD;
      sut[Souce Code] --> |Clang| ir[LLVM IR];
      ir --> |RecordReplay Instrumentation Pass| instr_ir[Instrumented IR];
      
      scheduler[Run Time Scheduler Library];
      
      instr_exe[Instrumented Executable];
      
      instr_ir --> instr_exe;
      scheduler --> instr_exe;
</div></div>

<!-- subsection:Combinatorial Explosion -->

---
## Combinatorial Explosion
- Simple Depth-First Search on State Space
- Problem: The number of possible thread interleavings grows exponentially with the size of the program!
- Solution: Prune state-space!
- Techniques to reduce the state space to explore, while still being able to give coverage guarantees

<!-- subsection:Bounded Search -->

---
## Bounded Search
- Prune the state space based on a "bounding function" (function on executions/traces) and a "bound value".
- Empirically, many bugs in concurrent software manifest are exposed by SOME schedule with small number of context
  switches/preemptions (TODO: citation)
- Already notion of different schedules leading to same behavior, some with high, some with low depth.
- Complexity: program with n threads that each execute at most k steps: O(n^(2c)k^c) schedules with c context-switches.
    polynomial in k, for fixed context-bound

<!-- citations
-   S. Qadeer and J. Rehof. 
    Context-bounded model checking of concurrent software. 
    In TACAS 05: Tools and Algorithms for the Construction and Analysis of Systems,
    volume 3440 of Lecture Notes in Computer Science, pages 93â€“107. Springer, 2005
-->

<!-- subsection:Partial Order Reduction -->

---
## Partial Order Reduction
- Prune state-space based on equivalence relation on executions/traces
- Complete: explore at least one schedule per equivalence class;
- Ideally explore a single trace/schedule per equivalence class to be fast



<!-- =============================================================================================================== -->
<!-- section:References -->

---
layout: true
# References

---
TODO


---


<!-- =============================================================================================================== -->
<!-- notes:
* Many tools available for testing / verifying sequential code (that is hard enough already!);
* Tool still in progress: not full support of C++11 memory model (e.g. visible sequences of side effects, atomics).


* Even though we see a tendency towards more and more high-level concurrency constructs (e.g. futures, coroutines) and 
programmers are more and more discouraged to use std::thread, and std::mutex, which become implementation details, there 
are domains where exactly these implementation details still matter (e.g. realtime systems, cyberphysical systems).
* Other examples such as CppMem (http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/).
* Runtime nature of the tool, but can still prove completeness of the exploration tree (e.q. using Coq).
* Something about the implementation details, i.e. vector clocks?


* Difference between software testing and software verification;
* General limitations of software verification and dynamic verification, e.g. non-halting programs excluded;
* Verification w.r.t. a *class* of bugs/errors, a specification (e.g. Datarace free);
* Difference between static analysis and dynamic analysis (e.g. examples from Flanagan/Godefroid).

section:Concurrency and Concurrency Errors 
- Test input is a program and a schedule, observation is execution/trace and execution result
- Difficult to reason about the interaction of threads

* Think about examples:
    - background_thread
    - workstealing_queue
    - double_instance
    - Depth-bounding examples from the paper, showing that empirically, many bugs have small depth
    - Example with large depth
    - Example where POR and optimal POR differ a lot
-->



<!-- =============================================================================================================== -->
<!--- section:THREADS -->

---
# Threads
.left[<img src='images/jpg/threads.001.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.002.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.003.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.004.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.005.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.006.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.007.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.008.jpeg' height="500"/>]
---
count: false
# Threads
.left[<img src='images/jpg/threads.009.jpeg' height="500"/>]

<!--- section:CONCURRENCY_HARD -->

---
# What's Hard About Concurrency?
### Shared Resources

```c++
int x, y, z = 0;

thread 0                   thread 1
--------                   --------

if (x == 1)                x = 1; 
{                          z = x + y;
   y = 1;                  std::cout << z << "\n";                   
}                                          
```

--
count: false
#### Datarace: 
Two (or more) threads access the same memory location *concurrently* and at least one 
of them is a *write*

---
# What's Hard About Concurrency?
### Synchronisation

```c++
array<int,2> nr_meals_eaten = {0, 0};
mutex fork1, fork2;

philosopher 0              philosopher 1
-------------              -------------

lock(fork1);               lock(fork2);
lock(fork2);               lock(fork1);
++nr_meals_eaten[0];       ++nr_meals_eaten[1];
unlock(fork2);             unlock(fork1);
unlock(fork1);             unlock(fork2);
```

---
# What's Hard About Concurrency?
### Synchronisation

```c++
array<int,2> nr_meals_eaten = {0, 0};
mutex fork1, fork2;

philosopher 0              philosopher 1
-------------              -------------

lock(fork1);               
                           lock(fork2);
lock(fork2);               
                           lock(fork1);
++nr_meals_eaten[0];       ++nr_meals_eaten[1];
unlock(fork2);             unlock(fork1);
unlock(fork1);             unlock(fork2);
```

--
count: false
#### Deadlock: 
Two or more threads wait for each other indefinitely

???
- False sharing: Threads running on different processor cores access different variables located in the same cache line frequently. This will slow down the involved threads due to frequent exchange of cache lines
- Lock contention: One thread blocks the progress of other threads by holding a lock too long

---
# What's Hard About Concurrency?
### State Space Explosion
--
count: false
```c++
int x, y, z = 0;

thread 0                   thread 1
--------                   --------

if (x == 1)                x = 1; 
{                          z = x + y;
   y = 1;                  std::cout << z << "\n";                   
}                                          
```

---
count: false
# What's Hard About Concurrency?
### State Space Explosion
Number of possible thread interleavings is *exponential* in the number of threads and instructions!
<br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

---
# What's Hard About Concurrency?
### Nondeterminism

The interleaving of threads is out of the programmer's control
<br/><br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

---
count: false
# What's Hard About Concurrency?
### Nondeterminism

The interleaving of threads is out of the programmer's control
<br/><br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion_buggy.jpg' width="800"/>]

???
It may depend on 
- load on the maschine 
- OS scheduler strategy

---
count: false
# What's Hard About Concurrency?
### Nondeterminism

The interleaving of threads is out of the programmer's control
<br/><br/><br/><br/>
.center[<img src='./images/jpg/state_space_explosion_good.jpg' width="800"/>]

<!--- section:CONCURRENCY_ERROR_DETECTORS -->

---
class: center, middle
# Concurrency Error Detectors

---
# Concurrency Error Detectors
### ThreadSanitzer
```shell
clang++ program_under_test.cpp -fsanitize=thread -o program_under_test
./program_under_test
```
--
count: false
#### Compiler Instrumentation (LLVM IR)

Instrument every potentially *visible* instruction (e.g. `load`, `store`)
--
count: false
```
define void @function() {
__tsan_func_entry(caller)
%2 = alloca i32
__tsan_store(%2)
store i32 %0, i32* %2
__tsan_load(%2)
%4 = load i32, i32* %2
ret i32 %4
__tsan_func_exit()
}
```

---
count: false
# Concurrency Error Detectors
### ThreadSanitzer
#### Runtime library
The `__tsan_` functions are callbacks to a Runtime Library (part of clang-rt)

Maintains a state maschine using shadow state for analysis

---
# Concurrency Error Detectors
### Helgrind
#### Binary Instrumentation
```shell
valgrind --tool=helgrind -v program
```

- Program is run on synthetic CPU provided by Valgrind Core 
- Threads are fully serialzed (only single CPU used)

---
# ThreadSanitizer & Helgrind: Data Races
<br/><br/>
<tr>
    <td><img src="./images/jpg/tsan_data-race-no-locks-hb.jpg" style="height: 300px;"/></td>
    <td><img src="./images/jpg/shadow_state_x.001.jpeg" style="height: 300px;"/></td>
</tr>

---
# ThreadSanitizer & Helgrind: Data Races
Using the *happens-before* relation:
<br/><br/>
<tr>
    <td><img src='./images/jpg/tsan_data-race-locks-hb-1.jpg' height="400"/></td>
</tr>
.center[]

---
count: false
# ThreadSanitizer & Helgrind: Data Races
Using the *happens-before* relation:
<br/><br/>
<tr>
    <td><img src='./images/jpg/tsan_data-race-locks-hb-2.jpg' height="400"/></td>
</tr>

---
count: false
# ThreadSanitizer & Helgrind: Data Races
Using the *happens-before* relation:
<br/><br/>
<tr>
    <td><img src='./images/jpg/tsan_data-race-locks-hb-3.jpg' height="400"/></td>
    <td><img src="./images/jpg/shadow_state_x.002.jpeg" style="height: 400px;"/></td>
</tr>

???
When a mutex is unlocked by thread T1 and later (or immediately) locked by thread T2, 
then the memory accesses in T1 prior to the unlock must happen-before those in T2 after 
it acquires the lock.

---
# ThreadSanitizer & Helgrind: Data Races
Limited information in *single* execution:
<br/><br/><br/>
.center[<img src='./images/jpg/tsan_data-race-branch-hb.jpg' height="375"/>]

---
# ThreadSanitizer: Deadlock
<img src='./images/jpg/tsan_deadlock.jpeg' height="500"/>

---
class: middle, center
# Systematic Exploration

---
# Systematic Exploration
<br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

<!--- section:SYSTEMATIC_EXPLORATION -->

---
# Taking Control Over the Thread Interleavings
#### LLVM IR Instumentation Pass

Replace 
```c++
pthread_create(pid, attr, start_routine, args)
pthread_join(pid)
``` 
by 
```c++ 
wrapper_spawn_thread(pid, attr, start_routine, args)
wrapper_pthread_join()
```

#### Scheduler
```c++
void wrapper_spawn_thread(pid, attr, start_routine, args)
{
   semaphores.insert({ pid, semaphore() })
   pthread_create(pid, attr, start_routine, args)
}
```

---
count: false
# Taking Control Over the Thread Interleavings
#### LLVM IR Instumentation Pass

Insert call to potentially *visible* instructions
```
wrap_post_task(instruction(store, %2, is_atomic))
store i32 %0, i32* %2
```

#### Scheduler
```c++
void wrapper_post_task(instruction)
{
   task_pool.insert({ this_thread::id(), instruction });
   semaphores[this_thread::id()].wait();
   // wait for turn
   
   task_pool.remove(this_thread::id());
   // perform instructions
}
```

---
count: false
# Taking Control Over the Thread Interleavings
#### Scheduler

```c++
void scheduler_thread(schedule)
{
   for (thread_id : schedule)
   {
      wait_until(task_pool.contains_key(thread_id));
      current_thread_id = thread_id;
      semaphore[thread_id].post();
      // notify the waiting thread
   }
}
```

---
# Systematic Exploration
### Simple depth-first exploration
State space explosion: becomes infeasible for larger programs
<br/><br/>
.center[<img src='./images/jpg/state_space_explosion.jpg' width="800"/>]

---
# State Space Reduction
- Explore only a subset of interleavings
- Provide coverage guarantees: quantify the class / number of interleavings seen

---
# Bounded Search
```cpp
bounded_search(program, bound_function, bound)
{
   for (interleaving : program.interleavings())
   {
      if (bound_function(interleaving) <= bound)
      {
         explore(interleaving);
      }
   }
}
```
--
count: zero
### Bound Functions
- Number of context-switches
- Number of preemptions

---
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-1.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-1-no-1.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-1-no-2.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 0
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-0-2.jpg' height="550"/>]

---
##### Bounded Search with Preemption Bound = 1
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-1-1.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 1
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-1-2.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 1
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-pre-1-3.jpg' height="550"/>]

---
count: false
##### Bounded Search with Preemption Bound = 1
<br/><br/><br/><br/><br/>
.left[<img src='./trees/bounded_search/jpg/work-stealing-queue-all-preemptions-1.jpg' width="750"/>]

---
# Bounded Search

### Advantages:
- Very fast for low bounds
- Quantifiable coverage
- Incremental

### Disadvantages:
- Incomplete
- For high bounds not better than depth first search

---
# Partial Order Reduction

Different interleavings may yield *equivalent* executions:
Ideally explore only a single one of those

--
count: false
#### Dependence Relation

```c++
bool dependent(memory_instr1, memory_instr2)
{
   return same_thread(memory_instr1, memory_instr2) || 
          ( same_operand(memory_instr1, memory_instr2) &&
            memory_instr1.is_write() || memory_inst2.is_write() );
}
```
```c++
bool dependent(lock_instr1, lock_instr2)
{
   return same_thread(lock_instr1, lock_instr2) || 
          ( same_operand(lock_instr1, lock_instr2) &&
            lock_instr1.is_lock() && lock_inst2.is_lock() );
}
```

---
# Partial Order Reduction 

<br/>
<tr>
    <td><img src='./images/jpg/happens_before_equivalence_class_1.jpg' width="350"/></td>
    <td><img src="./images/jpg/happens_before_equivalence_class_2.jpg" width="350"/></td>
</tr>

---
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_1.jpg' width="550"/>]

---
count: false
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_2.jpg' width="750"/>]
---
count: false
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_3.jpg' width="750"/>]

---
count: false
# Partial Order Reduction
<br/><br/>
.left[<img src='./images/jpg/dpor_data_race_example_4.jpg' width="750"/>]

---
# Partial Order Reduction

### Advantages:
- Complete coverage

### Disadvantages:
- Still infeasible for large state-spaces with many dependencies
- Not incremental

---
class: center, middle
# Thank you!

<!-- section:LINKS -->

---
# Links

#### Helgrind
http://valgrind.org/docs/manual/hg-manual.html

#### ThreadSanitizer:
https://github.com/google/sanitizers/wiki

#### My Project:
https://github.com/s-vde/record-replay

https://github.com/s-vde/state-space-explorer



      </textarea>
      
      <script src="../libs/mermaid/dist/mermaid.js"></script>
      <link rel="stylesheet" href="../libs/mermaid/dist/mermaid.forest.css">
      <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
      <script>
         var slideshow = remark.create({ 
            ratio: '16:9' 
         });
         mermaid.initialize({ 
            startOnLoad: false,
            cloneCssStyles: false
         });
         function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i=0; i < diagrams.length; i++) {
               if(diagrams[i].offsetWidth>0){
                  mermaid.init(undefined, diagrams[i]);
               }
            }
         }
         slideshow.on('afterShowSlide', initMermaid);
         initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);
      </script>
      
   </body>
</html>
