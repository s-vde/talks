<!DOCTYPE html>
<html>
   <head>
      <title>Testing and Verifying Multi-Threaded Programs</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <link rel="stylesheet" type="text/css" href="talk.css"/>
   </head>
   <body>
      <textarea id="source">


class: slide_title

<!-- section:Title
{
-->

# Automated Verification of Multi-Threaded Programs
### Susanne van den Elsen
Software Developer @ Native Instruments

### Meeting C++
November 10, 2017

<!--
}
end_section:section:Title -->



<!-- section:Introduction
{
-->

<!--
NOTE: 
@Timed: 1 min
Welcome everybody, thank you for coming, 
my name is Susanne van den Elsen and I will talk about 
"Automated Verification of Multi-Threaded programs".
- Software Developer @ NI
- Before that: doing research @ MPI-SWS
- Research focus: automated software verification
- In the context of one of my projects: I developed a tool for verifying
  multi-threaded programs, which I will present to you today

BRIDGE ==>: Before I do that, let me first provide an insight into why most standard
testing/debugging tools are insufficient for verifying multi-threaded programs.
-->

<!--
}
end_section:Introduction -->



<!-- section:Challenges in Testing Multi-Threaded Programs
   {
-->

---
layout: false
class: slide_section
# Challenges in Testing Multi-Threaded Programs

<!-- subsection:Concurrency Bugs
      {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs
# Concurrency Bugs

<!-- >>> Slide -->

---

--
count: false
##### Race Conditions
Arise when the program's correctness depends on the relative timing or ordering of thread 
instructions

--
count: false
##### Data Races
Arise when two threads
- access the same memory location concurrently; and 
- at least one of the accesses is a write

<!-- 
NOTE:
* memory location: since the c++11 memory model we can reason about memory accesses
* Data races are **Undefined Behaviour!**
-->

--
count: false
##### Deadlocks
Situation where a set of threads is blocked indefinitely because each of them is waiting for 
one of the others to release a held resource

<!-- <<< -->

<!-- subsubsection:Tools
         {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Concurrency Bugs
# Specialized Tools For Concurrency Bug Detection

<!-- >>> Slide -->

---

--
count: false
##### ThreadSanitizer and Helgrind

--
count: false
- Instrument the program (source vs. binary), run it, and observe its execution
- Deploy algorithms specifically tailored to detect data races (happens-before relation) and deadlocks (cycle detection)
  at run-time

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="h_example" style="margin-bottom: 2em;">data_race.cpp</div>
<div class="code_left" style="width: 35%;"><pre><code class="language-cpp">
int main()
{
   int x;
   
   thread thr1([&x](){
      x = 1;
   });
   
   thread thr1([&x](){
      x = 2;
   });
   
   thr1.join();
   thr2.join();
}
</code></pre></div>

--
count: false
<div class="code_right" style="width: 60%;"><pre><code class="language-bash">
clang++ -fsanitize=thread -std=c++14 -g data_race.cpp \
   -o data_race

./data_race
</code></pre></div>

--
exclude: true
<br/>
<img src='./generated_trees/trace_analysis/data_race.png' height="250"/>

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="h_example" style="margin-bottom: 2em;">deadlock.cpp</div>
<div class="code_left" style="width: 35%;"><pre><code class="language-cpp">
int main()
{
   mutex m1, m2;
   
   thread thr1([&m1, &m2](){
      lock_guard<mutex> lock1(m1);
      lock_guard<mutex> lock2(m2);
   });
   
   thread thr1([&m1, &m2](){
      lock_guard<mutex> lock2(m2);
      lock_guard<mutex> lock1(m1);
   });
   
   thr1.join();
   thr2.join();
}
</code></pre></div>

--
count: false
<div class="code_right" style="width: 60%;"><pre><code class="language-bash">
clang++ -std=c++14 -g deadlock.cpp -o deadlock

valgrind --tool=helgrind -v deadlock
</code></pre></div>

--
exclude: true

<!-- <<< -->

<!--
         }
end_subsubsection:Tools -->


<!-- subsection:Nondeterminism
      {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs
# Nondeterminism

<!-- >>> Slide -->

---

<!--
TODO:
NOTE:
* Nondeterminism itself not specific to mulit-threaded programs
* Single-threaded programs can have sources of nondeterminism, such as user input or randomization
* Threads add a different layer of nondeterminism:
   - The total order in which the threads get scheduled is outsourced to the OS scheduler and not 
   under the programmer's control
   - It may depend on e.g.:
      - load on the maschine 
      - OS scheduler strategy
   - The total order on which the threads operate on shared data often has an influence the 
   program's outcome
-->

<!-- <<< -->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Nondeterminism
# What does this mean for testing?

<!-- >>> Slide -->

---

--
count: false
##### Hard to get good test coverage:
- Running tests repeatedly without the guarantee that schedules will be different

--
count: false
- Some bugs only occur under very rare schedules
<!-- Approach of inducing bad schedules by forcing context-switches is not systematic! -->

--
count: false
- "Heisenbugs" may even disappear as a result of changes in timing introduced by the debugging tool
<!-- bugs that tend to disappear when you want to find them -->

--
count: false
##### Bugs are hard to reproduce: 
- If buggy behavior is observed, the next execution may be under a different schedule

<!-- <<< -->

<!--
BRIDGE:
Introduce two small example programs that demonstrate the challenge of nondeterminism for testing.
These programs will later be used to demonstrate systematic exploration.
-->

<!-- example:bank_account.cpp
            {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Nondeterminism
# Example: bank_account.cpp


<!-- >>> Slide -->

---

```cpp
struct bank_account { atomic<int> balance; }

void transfer(bank_account& from, int amount, bank_account& to);
```
--
count: false
```cpp
TEST(BalancesArePositive)
{
   array<bank_account, 2> accounts = {{ 100, 0 }};
   thread mallory(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   thread marvin(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   
   mallory.join();
   marvin.join();
   
   ASSERT(all_of(accounts.begin(), accounts.end(), [](auto balance){ positive(balance); }));
}
```

<!-- <<< -->

<!-- >>> Slide -->

---

```cpp
struct bank_account { atomic<int> balance; }

void transfer(bank_account& from, int amount, bank_account& to)
{
   const auto balance_from = from.balance.load();
   if (balance_from >= amount)
   {
      to.balance.fetch_add(amount);
      from.balance.fetch_sub(amount);
   }
}
```

--
count: false
```cpp
mallory                                      marvin                                       accounts

balance_from = from.balance.load() = 100;                                                 { 100,  0   }
to.balance.fetch_add(amount);                                                             { 100,  100 }
from.balance.fetch_sub(amount);                                                           { 0,    100 }
                                             balance_from = from.balance.load() = 0;      { 0,    100 }
```

--
count: false
```cpp
// assertion holds :)
ASSERT(all_of(accounts.begin(), accounts.end(), [](auto balance){ positive(balance); }));
```

<!-- <<< -->

<!-- >>> Slide -->

---

```cpp
struct bank_account { atomic<int> balance; }

void transfer(bank_account& from, int amount, bank_account& to)
{
   const auto balance_from = from.balance.load();
   if (balance_from >= amount)
   {
      to.balance.fetch_add(amount);
      from.balance.fetch_sub(amount);
   }
}
```

```cpp
mallory                                      marvin                                       accounts

balance_from = from.balance.load() = 100;                                                 { 100,  0   }
                                             balance_from = from.balance.load() = 100;    { 100,  0   }
                                             to.balance.fetch_add(amount);                { 100,  100 }
                                             from.balance.fetch_sub(amount);              { 0,    100 }
to.balance.fetch_add(amount);                                                             { 0,    200 }
from.balance.fetch_sub(amount);                                                           { -100, 200 }         

```

--
count: false
```cpp
// assertion is violated :(!
ASSERT(all_of(accounts.begin(), accounts.end(), [](auto balance){ positive(balance); }));
```

<!-- <<< -->

<!-- >>> Slide -->

---

```bash
clang++ -std=c++14 -g bank_account.cpp -o bank_account
valgrind --tool=helgrind ./bank_account
```

<!-- <<< -->

<!--
            }
end_example:bank_account.cpp -->

<!-- example:background_thread.cpp
            {
-->

---
layout: true
#### Challenges in Testing Multi-Threaded Programs | Nondeterminism
# Example: background_thread.cpp

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>

--
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
int main()
{
   background_thread_manager m;
   m.run_thread();
   m.run_thread();
   
   m.join_thread();
}
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
main                          m_thread          | m_mutex
                                                |
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == false                    |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                              m_mutex.lock()    | locked
                              // perform task   |
                              m_mutex.unlock()  | unlocked
m_mutex.try_lock()                              | locked
m_thread.joinable() == true                     |
m_thread.join()                                 |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                              m_mutex.lock()    | locked
                              // perform task   |
                              m_mutex.unlock()  | unlocked
m_thread.join()                                 |    
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---
<div class="code_left" style="width: 40%;"><pre><code class="language-cpp">
struct background_thread_manager
{
   void run_thread() {
      if (!m_mutex.try_lock())
         return;
      
      join_thread();
   
      m_thread([this]() {
         m_mutex.lock();
         // perform task
         m_mutex.unlock();
      });
   
      m_mutex.unlock();
   }
   
   void join_thread() {
      if (m_thread.joinable())
         m_thread.join();
   }
   
   thread m_thread;
   mutex m_mutex;
};
</code></pre></div>
<div class="code_right" style="width: 59%;"><pre><code class="language-cpp">
main                          m_thread          | m_mutex
                                                |
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == false                    |
m_thread.spawn()                                |
m_mutex.unlock()                                | unlocked
                                                |
m_mutex.try_lock()                              | locked
m_thread.joinable() == true                     |
                                                |
DEADLOCK:                                       |
m_thread.join()               m_mutex.lock()    |
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---

```bash
clang++ -std=c++14 -g background_thread.cpp -o background_thread
valgrind --tool=helgrind ./background_thread
```

<!-- <<< -->

<!--
            }
end_example:background_thread.cpp -->

<!--
      }
end_subsubsection:Nondeterminism -->

<!--
}
end_section:section:Challenges in Testing Multi-Threaded Programs -->





<!-- section:Systematic Exploration
   {
-->

---
layout: false
class: slide_section
# Systematic Exploration

---
layout: true
#### Systematic Exploration

<!-- >>> Slide -->

---

# The Idea

--
count: false
- Take control over the interleaving of the threads' "visible instructions"

--
count: false
- Systematically drive the program under test through a set of relevant schedules
<!-- NOTE: schedules are the test-cases -->

--
count: false
   - Relevant schedules are computed on-the-fly, based on the recording of the previous execution

--
count: false
- Buggy schedules are stored so that the bug can be reproduced

<!-- <<< -->

---
layout: true
#### Systematic Exploration
# RecordReplay library: Taking "Control" over the Scheduler

<!-- >>> Slide -->

---

<div class="mermaid" style="align: center; width: 60%; margin: 0px auto;">
   graph TD
      sut[Souce Code] --> |Clang| ir[LLVM IR]
      ir --> |RecordReplay Instrumentation Pass| instr_ir[Instrumented IR]
      scheduler[Run Time Scheduler Library]
      instr_exe[Instrumented Executable]
      instr_ir --> instr_exe
      scheduler --> instr_exe
</div>

<!-- NOTE: LLVM IR: low-level assembly-like language that is designed so that many higher level 
langauges can be mapped to it;
-->

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
   ; Function Attrs: norecurse ssp uwtable
   define i32 @main() local_unnamed_addr #3 !dbg !478 {
   entry:
     call void @wrapper_register_main_thread(), !dbg !479
     call void @wrapper_enter_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !479
     %call = tail call i32 @pthread_mutex_init(%struct._opaque_pthread_mutex_t* nonnull @m1, %struct._opaque_pthread_mutexattr_t* null), !dbg !479
     %call1 = tail call i32 @pthread_mutex_init(%struct._opaque_pthread_mutex_t* nonnull @m2, %struct._opaque_pthread_mutexattr_t* null), !dbg !480
     %0 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thr1, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 35)
     %call2 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thr1, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z7thread1Pv, i8* null), !dbg !481
     call void @wrapper_register_thread(%struct._opaque_pthread_t** @thr1, i32 %0)
     %1 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thr2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 36)
     %call3 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thr2, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z7thread2Pv, i8* null), !dbg !482
     call void @wrapper_register_thread(%struct._opaque_pthread_t** @thr2, i32 %1)
     call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thr1 to i8*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_mem_loc_name_thr1, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 38)
     %2 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thr1, align 8, !dbg !483, !tbaa !484
     call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 38)
     %call4 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %2, i8** null), !dbg !488
     call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thr2 to i8*), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_mem_loc_name_thr2, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 39)
     %3 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thr2, align 8, !dbg !489, !tbaa !484
     call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 39)
     %call5 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %3, i8** null), !dbg !490
     call void @wrapper_exit_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !491
     ret i32 0, !dbg !491
   }
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
   ; Function Attrs: noreturn ssp uwtable
   define noalias nonnull i8* @_Z7thread1Pv(i8* nocapture readnone %arg) #0 !dbg !457 {
   entry:
     call void @wrapper_enter_function(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @_recrep_function_name__Z7thread1Pv, i32 0, i32 0)), !dbg !462
     tail call void @llvm.dbg.value(metadata i8* %arg, i64 0, metadata !461, metadata !463), !dbg !462
     call void @wrapper_post_lock_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_mutex_t* @m1 to i8*), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @_mem_loc_name_m1, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 14)
     %call = tail call i32 @pthread_mutex_lock(%struct._opaque_pthread_mutex_t* nonnull @m1), !dbg !464
     call void @wrapper_post_lock_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_mutex_t* @m2 to i8*), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @_mem_loc_name_m2, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 15)
     %call1 = tail call i32 @pthread_mutex_lock(%struct._opaque_pthread_mutex_t* nonnull @m2), !dbg !465
     call void @wrapper_post_lock_instruction(i32 1, i8* bitcast (%struct._opaque_pthread_mutex_t* @m2 to i8*), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @_mem_loc_name_m2, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 16)
     %call2 = tail call i32 @pthread_mutex_unlock(%struct._opaque_pthread_mutex_t* nonnull @m2), !dbg !466
     call void @wrapper_post_lock_instruction(i32 1, i8* bitcast (%struct._opaque_pthread_mutex_t* @m1 to i8*), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @_mem_loc_name_m1, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/deadlock_pthread.cpp", i32 0, i32 0), i32 17)
     %call3 = tail call i32 @pthread_mutex_unlock(%struct._opaque_pthread_mutex_t* nonnull @m1), !dbg !467
     call void @wrapper_exit_function(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @_recrep_function_name__Z7thread1Pv, i32 0, i32 0)), !dbg !468
     tail call void @pthread_exit(i8* null) #6, !dbg !468
     unreachable, !dbg !468
   }
</code></pre></div>

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="code_left" style="width: 45%;">
<pre><code class="language-cpp">
scheduler::_spawn_thread(pthread_t pid)
{
   return next_thread_id();
}
</code></pre>

<pre><code class="language-cpp">
scheduler::_register_thread(pthread_t pid, int tid)
{
   m_thread_ids[pid] = tid;
   m_controllable_threads[tid] = semaphore();
}
</code></pre>

<!-- NOTE: associate with newly created thread a semaphore -->

<pre><code class="language-cpp">
scheduler::_post_instruction(instr_t instruction)
{
   m_task_pool[pthread_self()] = instruction;
   m_controllable_threads[tid].wait();
   
   // perform the posted instruction
   // and execute until the next wrapper call
}
</code></pre>
</div>

--
count: false
<div class="code_right" style="width:54%;">
<pre><code class="language-cpp">
scheduler::scheduler_thread(schedule_t schedule)
{
   while (true)
   {
      execution_t execution;
      
      // wait until all active threads posted an instruction
      
      // compute the next thread to be scheduled
      int next_tid = 
         selection_strategy(m_task_pool, schedule);
      
      // record the task_pool and the next instruction
      execution.push_back(m_task_pool, m_task_pool[next_tid]);
      
      // allow the next thread to progress until its next 
      // wrapper call
      m_controllable_threads[next_tid].post();
   }
}
</code></pre>
</div>

<!-- 
NOTE: 
- at any point in time at most a single thread not blocked on their semaphore
- underlying OS scheduler is forced to schedule the thread that particular thread
-->

<!-- <<< -->

---
exclude: true
# RecordReplay Library
<div class="mermaid" style="align: center; width: 60%; margin: 0px auto;">
   graph LR
      schedule[Schedule<br/><br/>00001111] --> instr_exe[Instrumented Executable]
      instr_exe --> trace[Trace<br/><br/>0 lock mutex</br>0 load x1<br/>0 store x1<br/>0 unlock mutex<br/>1 load x1<br/>1 load x2<br/>1 store x3<br/>1 store x1]
</div></div>

<!-- >>> Slide -->

---
layout: true
#### Systematic Exploration
# Exploration Algorithms

---
<div class="mermaid" style="align: center; width: 80%; margin: 0px auto;">
   graph TD
      exploration[Exploration Algorithm]
      
      exploration --> |00001111| instr_exe1[Instrumented<br/>Executable]
      instr_exe1 --> |trace| exploration
      
      exploration --> |00011110| instr_exe2[Instrumented<br/>Executable]
      instr_exe2 --> |trace| exploration
      
      exploration --> |....| instr_exei[Instrumented<br/>Executable]
      instr_exei --> |trace| exploration
      
      exploration --> |11110000| instr_exen[Instrumented<br/>Executable]
      instr_exen --> |trace| exploration
</div>

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms

---

<!-- >>> Slide -->

---
# Depth-First Exploration

--
count: false
```cpp
depth_first_exploration(program)
{
   for (schedule : possible_schedules(program))
   {
      run(program, schedule);
   }
}
```

<!-- <<< -->

<!-- >>> Slide -->

---
# Combinatorial Explosion!
<div class="h_example">data_race.cpp</div>
.center[<img src='./generated_trees/data_race.cpp/depth_first_search/trees/full_schedules.png' width="1100"/>]

<!-- 
NOTE:
Problem:    The number of possible thread interleavings grows exponentially with the size of the program!
Solution:   Prune the tree of schedules to consider
Challenge:  Coverage Guaranteees: quantify the class / number of interleavings seen
-->

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration

<!-- >>> Slide -->

---

```cpp
bounded_exploration(program, bound_function, bound_value)
{
   for (schedule : possible_schedules(program))
   {
      if (bound_function(schedule) <= bound_value)
      {
         run(program, schedule);
      }
   }
}
```

<!-- 
NOTE:
bound function:  a function on schedules (e.g. length, number of context-switches, 
                 number of preemptions)
-->

<!-- <<< -->

<!-- >>> Slide -->

---

##### :( Incomplete
With low bound value, not all program behaviors may be covered

--
count: false

##### :) Often sufficient (with right bound functions)
[Musuvathi and Qadeer]: Empirically, many bugs in multi-threaded programs are exposed by *some* schedule with small number 
of preemptions

--
count: false

##### :) Iterative
[Musuvathi and Qadeer]: Start with low bound value and iteratively increase it to gain better coverage

--
count: false

##### :( Redundant
- May still explore many schedules that lead to program executions with the same *behavior*
- In the limit: same as depth first search

<!-- NOTE: 
This point has already has a notion of different schedules leading to the same behaviour,
some with high and some with low preemption number

Program with n threads that each execute at most k steps and a context-bound of c:
O(n^(2c)k^c) schedules with c context-switches.
Polynomial in k for fixed context-bound
-->

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration
<span class="h_example">background_thread.cpp, preemptions=0</span>

<!-- >>> Slide -->

---

---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/background_thread.cpp/bounded_search/0/trees/animations/0.png' height="560"/>]
</div>
---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/background_thread.cpp/bounded_search/0/trees/animations/1.png' height="560"/>]
</div>
---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/background_thread.cpp/bounded_search/0/trees/animations/2.png' height="560"/>]
</div>

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration
<span class="h_example">bank_account.cpp, preemptions=0</span>

<!-- >>> Slide -->

---

---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/0/trees/animations/0.png' height="560"/>]
</div>
---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/0/trees/animations/1.png' height="560"/>]
</div>
---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/0/trees/animations/2.png' height="560"/>]
</div>

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration
<span class="h_example">bank_account.cpp, preemptions=1</span>

<!-- >>> Slide -->

---

---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/animations/0.png' height="560"/>]
</div>
---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/animations/1.png' height="560"/>]
</div>
---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/animations/2.png' height="560"/>]
</div>
---
count: false
<div class="animation_bs" style="margin-right: 1em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/full_schedules.png' height="560"/>]
</div>

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Partial Order Reduction

<!-- >>> Slide -->

---

--
count: false
```cpp
partial_order_reduction(program, equivalence_relation)
{
   for (equivalence_class : equivalence_classes(program, equivalence_relation))
   {
      schedule = representative(equivalence_class);
      run(program, schedule);
   }
}
```

<!-- 
NOTE: 
equivalence relation: groups schedules that lead to the same observable program behaviour 
-->

<!-- <<< -->

---

<!-- TODO: dependence, happens-before -->

<!-- >>> Slide -->

---

##### :) Complete
Explores at least one schedule per equivalence class

--
count: false
##### :) Ideally non-redundant
Ideally explores exactly one schedule per equivalence class

--
count: false
##### :( No obvious coverage versus resources trade-off 
- For large programs with many dependencies between threads, partial order reduction may still be 
infeasible
- No iterative approach with incomplete but quantifiable coverage guarantees

<!-- <<< -->

<!-- >>> Slide -->

---
layout: true
#### Systematic Exploration - Exploration Algorithms
# Partial Order Reduction
<span class="h_example">background_thread.cpp</span>
---
---
count: false
<div class="animation_dpor" style="margin-top: -7em">
   .right[<img src='./generated_trees/background_thread.cpp/dpor/trees/animations/0.png' height="560"/>]
</div>
---
count: false
<div class="animation_dpor" style="margin-top: -7em">
   .right[<img src='./generated_trees/background_thread.cpp/dpor/trees/animations/1.png' height="560"/>]
</div>

<!-- <<< -->

<!-- >>> Slide -->

---
layout: true
#### Systematic Exploration - Exploration Algorithms
# Partial Order Reduction
<span class="h_example">bank_account.cpp</span>
---
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/0.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/1.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/2.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/3.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/4.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/5.png' width="1150"/>]
</div>

<!-- <<< -->





<!-- >>> Slide -->

---
count: false
layout: false
class: slide_section
# Thank you!

<!-- <<< -->

---
layout: true
# References

<!-- >>> Slide -->

---
count: false
### Tools
<span class="h_link">StateSpaceExplorer:</span>
https://github.com/s-vde/state-space-explorer

<span class="h_link">Helgrind:</span>
http://valgrind.org/docs/manual/hg-manual.html

<span class="h_link">ThreadSanitizer:</span>
https://github.com/google/sanitizers/wiki

<br/><br/>
<span class="h_link">CHESS:</span>
https://chesstool.codeplex.com

<span class="h_link">Maple:</span>
https://github.com/jieyu/maple

<!-- <<< -->

<!-- >>> Slide -->

---
count: false
### Selected Literature
C. Flanagan and P. Godefroid (2005),
*Dynamic Partial-Order Reduction for Model Checking Software*,
In: POPL' 05,
pages 110-121
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1040315

P. Godefroid (1997),
*Model Checking for Programming Languages using VeriSoft*,
InL POPL'97,
pages 174-186
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=263717&CFID=824726696&CFTOKEN=68367255

M. Musuvathi and S. Qadeer (2007),
*Iterative Context Bounding for Systematic Testing of Multithreaded Programs*,
In: PLDI' 07,
pages 446-455
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1040315

M. Musuvathi et al. (2008), 
*Finding and Reproducing Heisenbugs in Concurrent Programs*,
In OSDI'08,
pages 267-280
<br class="br_link" />
https://dl.acm.org/citation.cfm?id=1855760

<!-- <<< -->





      </textarea>
      
      <script src="../libs/mermaid/dist/mermaid.js"></script>
      <link rel="stylesheet" href="../libs/mermaid/dist/mermaid.forest.css">
      <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
      <script>
         var slideshow = remark.create({ 
            ratio: '16:9' 
         });
         mermaid.initialize({ 
            startOnLoad: false,
            cloneCssStyles: false
         });
         function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i=0; i < diagrams.length; i++) {
               if(diagrams[i].offsetWidth>0){
                  mermaid.init(undefined, diagrams[i]);
               }
            }
         }
         slideshow.on('afterShowSlide', initMermaid);
         initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);
      </script>
      
   </body>
</html>
