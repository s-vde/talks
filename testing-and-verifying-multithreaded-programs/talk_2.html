<!DOCTYPE html>
<html>
   <head>
      <title>Testing and Verifying Multi-Threaded Programs</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <link rel="stylesheet" type="text/css" href="talk.css"/>
   </head>
   <body>
      <textarea id="source">





<!-- section:Title -->

class: slide_title, no_number
count: false

# Automated Verification of Multi-Threaded Programs
### Susanne van den Elsen
Software Developer @ Native Instruments

### Meeting C++
November 10, 2017



<!-- >>> Slide -->

???
BRIDGE FROM:
I am going to present how this basic idea is implemented in the systematic 
exploration tool that I build.
I will start by the RecordReplay library and how it assumes control over the runtime scheduler.

---
count: false
# The Idea
- **RecordReplay Library**: Take control over the interleaving of the program's threads at runtime
- Systematically drive the program through a set of relevant schedules

<!-- >>> Slide -->

---

<div class="code_left" style="width: 45%;">
<pre><code class="language-cpp">
scheduler::_register_thread(pthread_t pid)
{
   m_thread_ids[pid] = next_thread_id();
   m_controllable_threads[tid] = semaphore();
}
</code></pre>
</div>

???
The thread registration associates with each newly created thread a semaphore that allows the 
Scheduler to control that thread.

---
count: false

<div class="code_left" style="width: 45%;">
<pre><code class="language-cpp">
scheduler::_register_thread(pthread_t pid)
{
   m_thread_ids[pid] = next_thread_id();
   m_controllable_threads[tid] = semaphore();
}
</code></pre>

<pre><code class="language-cpp">
scheduler::_post_instruction(instr_t instruction)
{
   tid = m_thread_ids[pthread_self()];
   m_task_pool[tid] = instruction;
   m_controllable_threads[tid].wait();
   
   // perform the posted instruction
   // and execute until the next wrapper call
}
</code></pre>
</div>

???
When a thread posts an instruction (thread creation or joining, memory or lock instruction) to the 
Scheduler the calling thread:
- First adds its instruction to the Scheduler's task pool, which is a map from thread ids to the 
  next instruction of the corresponding thread.
- Then the calling thread blocks on its semaphore until the Scheduler posts the semaphore.
- Then the thread can continue execution until it calls a Scheduler function again.

---
count: false

<div class="code_left" style="width: 45%;">
<pre><code class="language-cpp">
scheduler::_register_thread(pthread_t pid)
{
   m_thread_ids[pid] = next_thread_id();
   m_controllable_threads[tid] = semaphore();
}
</code></pre>

<pre><code class="language-cpp">
scheduler::_post_instruction(instr_t instruction)
{
   tid = m_thread_ids[pthread_self()];
   m_task_pool[tid] = instruction;
   m_controllable_threads[tid].wait();
   
   // perform the posted instruction
   // and execute until the next wrapper call
}
</code></pre>
</div>

???
- The scheduling routine runs in the scheduler thread, which has access to all the Scheduler 
  datastructures.
- At every scheduling round, the scheduler thread first waits until all the registered and 
  unfinished threads have posted their next instruction
- Then it determines the next thread to execute
   - First it looks whether the next thread is dictated by the given schedule
   - Otherwise it applies the given selection strategy which computes the next thread based on the 
     current taskpool and the thread interleaving up to this round
   - Possible strategies include a random selection from the enabled threads, or a selection that 
     always picks the thread that was scheduled last, if it is enabled.
- After choosing the next thread, the scheduler thread records the state of the taskpool and the 
  next instruction to the execution trace.
- Then it enables the next thread to continue execution by posting that thread's semaphore and 
  sending a notification.
- Since at each time at most one thread is not blocked on its sempahore, the underlying OS 
  scheduler is forced to schedule that particular thread.
  
Since the program threads and the scheduler thread operate on shared data structures, these 
accesses are coordinated very carefully in order not to actually introduce deadlocks and dataraces.

<!-- <<< -->


---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration

<!-- >>> Slide -->

---

```cpp
bounded_exploration(program, bound_function, bound)
{
   for (schedule : possible_schedules(program))
   {
      if (bound_function(schedule) <= bound)
      {
         run(program, schedule);
      }
   }
}
```

???
One technique to prune the space of schedules is Bounded Exploration.
Apart from an input program, Bounded Exploration takes a bound function, which is a function 
on schedules and a bound.
It only considers those schedules whose bound value is less than or equal to the bound.

- A bound function that works well in practice is the function that maps a schedule to the 
  number of times it preempts a thread.
 
<!-- TODO: define preemption -->

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration
<span class="h_example">background_thread.cpp, preemptions=0</span>

<!-- >>> Slide -->

---

---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/background_thread.cpp/bounded_search/0/trees/animations/0.png' height="560"/>]
</div>

???
Bounded Exploration works very similar to Depth-First exploration. 
When backtracking, it additionally checks whether the new schedule exceeds the bound.

---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/background_thread.cpp/bounded_search/0/trees/animations/1.png' height="560"/>]
</div>

???
Backtracking this branch, Bounded Exploration skips many schedules that Depth-First exploration 
would explore.

---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/background_thread.cpp/bounded_search/0/trees/animations/2.png' height="560"/>]
</div>

???
BRIDGE FROM:
The background_thread example clearly demonstrates the advantages of Bounded Exploration

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration

<!-- >>> Slide -->

---
##### :) Very strong reduction
With low bounds a large part of the space of schedules is pruned away

--
count: false
##### :) Low bounds often sufficient (with right bound functions)
[Musuvathi and Qadeer]: Empirically, many bugs in multi-threaded programs are exposed by *some* 
schedule with small number of preemptions

???
By exploring only three schedules, Bounded Exploration found the deadlock in the background_thread 
example. Research suggests that this is often the case in practice and that many bugs are 
exposed with low bounds, assuming the right bound function is chosen.

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration
<span class="h_example">bank_account.cpp, preemptions=0</span>

<!-- TODO: Think about only showing the full schedules from here -->

<!-- >>> Slide -->

---

???
The bank_account example shows that low bounds may not always find existing bugs in a program.

---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/0/trees/animations/0.png' height="560"/>]
</div>
---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/0/trees/animations/1.png' height="560"/>]
</div>
---
count: false 
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/0/trees/animations/2.png' height="560"/>]
</div>

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration
<span class="h_example">bank_account.cpp, preemptions=1</span>

<!-- >>> Slide -->

---

---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/animations/0.png' height="560"/>]
</div>
---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/animations/1.png' height="560"/>]
</div>
---
count: false
<div class="animation_bs" style="margin-right: 6em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/animations/2.png' height="560"/>]
</div>
---
count: false
<div class="animation_bs" style="margin-right: 1em;">
   .right[<img src='./generated_trees/bank_account.cpp/bounded_search/1/trees/full_schedules.png' height="560"/>]
</div>

<!-- <<< -->

---
layout: true
#### Systematic Exploration | Exploration Algorithms
# Bounded Exploration

<!-- >>> Slide -->

---

##### :( Incomplete
With low bound value, not all program behaviors may be covered

--
count: false
##### :( Redundant
- May still explore many schedules that lead to program executions with the same *behavior*
- In the limit: same as depth first search

--
count: false
##### :) Iterative
[Musuvathi and Qadeer]: Start with low bound value and iteratively increase it to gain better 
coverage

???
Redundant: bounded exploration with preemption bound 1 discovered the same assertion failure in
many executions.

BRIDGE FROM:
Redundancy is exactly the problem that is tackled by the last pruning technique I will discuss:
Partial Order Reduction

<!-- 
NOTE: 
This point has already has a notion of different schedules leading to the same behaviour,
some with high and some with low preemption number

Program with n threads that each execute at most k steps and a context-bound of c:
O(n^(2c)k^c) schedules with c context-switches.
Polynomial in k for fixed context-bound
-->

<!-- <<< -->



<!-- >>> Slide -->

---
layout: true
#### Systematic Exploration - Exploration Algorithms
# Partial Order Reduction
<span class="h_example">bank_account.cpp</span>
---
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/0.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/1.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/2.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/3.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/4.png' width="1150"/>]
</div>
---
count: false
<div class="animation_dpor">
   .right[<img src='./generated_trees/bank_account.cpp/dpor/trees/animations/5.png' width="1150"/>]
</div>

<!-- <<< -->



<!-- ////////// -->




      </textarea>
      
      <script src="../libs/mermaid/dist/mermaid.js"></script>
      <link rel="stylesheet" href="../libs/mermaid/dist/mermaid.forest.css">
      <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
      <script>
         var slideshow = remark.create({ 
            ratio: '16:9',
            highlightLanguage: 'cpp',
            highlightStyle: 'github',
            highlightLines: true
         });
         mermaid.initialize({ 
            startOnLoad: false,
            cloneCssStyles: false
         });
         function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i=0; i < diagrams.length; i++) {
               if(diagrams[i].offsetWidth>0){
                  mermaid.init(undefined, diagrams[i]);
               }
            }
         }
         slideshow.on('afterShowSlide', initMermaid);
         initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);
      </script>
      
   </body>
</html>
