<!DOCTYPE html>
<html>
   <head>
      <title>Testing and Verifying Multi-Threaded Programs</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
      <link rel="stylesheet" type="text/css" href="talk.css"/>
   </head>
   <body>
      <textarea id="source">





<!-- section:Title -->

class: slide_title, no_number
count: false

# Automated Verification of Multi-Threaded Programs
### Susanne van den Elsen
Software Developer @ Native Instruments

### Meeting C++
November 10, 2017

<!-- <<< -->

<!-- example:bank_account.cpp -->

<!-- >>> Slide -->

---
```cpp
struct bank_account { atomic<int> balance; }

void transfer(bank_account& sender, int amount, bank_account& receiver);
```

???
A bank account has a balance and there is a function for transferring a given amount of money from
one bank account (sender) to the other (the receiver).
The specification of the transfer function states that when the function returns, the balances 
of both involved accounts are non-negative.

One test case for the transfer function checks that this is true in case two threads attempt to 
transfer the whole amount of money out of the same account concurrently.

--
count: false
```cpp
TEST(AfterConcurrentTransfersBalancesArePositive)
{
   array<bank_account, 2> accounts = {{ 100, 0 }};
   thread mallory(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   thread marvin(transfer, ref(accounts[0]), 100, ref(accounts[1]));
   
   mallory.join();
   marvin.join();
   
   ASSERT(accounts[0] >= 0 && accounts[1] >= 0);
}
```

???
- There are two accounts, one with an initial balance of 100, and one with an initial balance of 0
- Two adversary threads, Mallory and Marvin both try to transfer 100 euros from the first to the 
  second account.
- Obviously, if the program meets the specification, at least one of them should not succeed
- The assertion states that after both threads are joined, both accounts have non-negative balance.

<!-- <<< -->

<!-- >>> Slide -->

---

```cpp
void transfer(bank_account& sender, int amount, bank_account& receiver)
{
   const auto balance_sender = sender.balance.load();
   if (balance_sender >= amount)
   {
      receiver.balance.fetch_add(amount);
      sender.balance.fetch_sub(amount);
   }
}
```

???
Here is an *attempt* at an implementation of the transfer function.
1. First, the balance of the sender's account is atomically read and stored in a local variable
2. Then, the function checks if that balance is sufficient for transferring the given amount of 
   money out of it
3. If so, it atomically adds the amount to the receiver's account and 
   subsequently subtracts the same amount from the sender's account.

<!-- <<< -->

<!-- >>> Slide -->

--
```cpp
mallory                                         marvin                                          accounts

                                                                                                { 100,  0   }
balance_sender = sender.balance.load() = 100;                                                
receiver.balance.fetch_add(amount);                                                             { 100,  100 }
sender.balance.fetch_sub(amount);                                                               { 0,    100 }
                                                balance_sender = sender.balance.load() = 0;  
```

--
count: false
```cpp
ASSERT(accounts[0] >= 0 && accounts[1] >= 0);   // assertion holds :(
```

<!-- <<< -->

<!-- >>> Slide -->

---

```cpp
void transfer(bank_account& sender, int amount, bank_account& receiver)
{
   const auto balance_sender = sender.balance.load();
   if (balance_sender >= amount)
   {
      receiver.balance.fetch_add(amount);
      sender.balance.fetch_sub(amount);
   }
}
```

```cpp
mallory                                         marvin                                          accounts

                                                                                                { 100,  0   }
balance_sender = sender.balance.load() = 100;                                                 
                                                balance_sender = sender.balance.load() = 100;
                                                receiver.balance.fetch_add(amount);             { 100,  100 }
                                                sender.balance.fetch_sub(amount);               { 0,    100 }
receiver.balance.fetch_add(amount);                                                             { 0,    200 }
sender.balance.fetch_sub(amount);                                                               { -100, 200 }         

```

--
count: false
```cpp
ASSERT(accounts[0] >= 0 && accounts[1] >= 0);   // assertion is violated :)
```

???
Whether or not the executing the unit test reveals the bug depends on the interleaving of the two 
threads at runtime.

This brings me to the second challenge for testing and verifying multi-threaded programs:
From the viewpoint of the programmer, this interleaving is nondeterministic.

<!-- <<< -->

<!-- backup_slides:Instrumentation>

---
layout: true
#### Systematic Exploration
# RecordReplay library: Taking "Control" over the Scheduler

<!-- >>> Slide -->

---
exclude: true
```cpp
int x = 0;
pthread_t thread1, thread2;
int values[2] = {0, 1};
pthread_mutex_t mutex;

void* thread_routine(void* arg) {
   int value = *(int*) arg;
   pthread_mutex_lock(&mutex);
   x = value;
   pthread_mutex_unlock(&mutex);
   pthread_exit(0);
}

int main() {
   pthread_mutex_init(&mutex, 0);
   pthread_create(&thread1, 0, thread_routine, values + 0);
   pthread_create(&thread2, 0, thread_routine, values + 1);
   pthread_join(thread1, 0);
   pthread_join(thread2, 0);

   return 0;
}
```

<!-- <<< -->

<!-- >>> Slide -->

---

<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define i32 @main() local_unnamed_addr #3 !dbg !78 {
  call void @wrapper_register_main_thread(), !dbg !81
  call void @wrapper_enter_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !81
  %0 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread1, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 28)
  %call1 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread1, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast ([2 x i32]* @values to i8*)), !dbg !82
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread1, i32 %0)
  %1 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 29)
  %call2 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread2, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast (i32* getelementptr inbounds ([2 x i32], [2 x i32]* @values, i64 0, i64 1) to i8*)), !dbg !83
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread2, i32 %1)
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread1 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread1, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %2 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread1, align 8, !dbg !84, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %call3 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %2, i8** null), !dbg !87
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread2 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread2, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %3 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread2, align 8, !dbg !88, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %call4 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %3, i8** null), !dbg !89
  call void @wrapper_exit_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !90
  ret i32 0, !dbg !90
}
</code></pre></div>

???
In the next slides you'll see the human-redable dump of the LLVM intermediate representation of a 
simple multi-threaded program with pthreads. This is the intermediate representation of the 
program's main function

---
count: false
<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define i32 @main() local_unnamed_addr #3 !dbg !78 {
* call void @wrapper_register_main_thread(), !dbg !81
  call void @wrapper_enter_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !81
  %0 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread1, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 28)
  %call1 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread1, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast ([2 x i32]* @values to i8*)), !dbg !82
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread1, i32 %0)
  %1 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 29)
  %call2 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread2, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast (i32* getelementptr inbounds ([2 x i32], [2 x i32]* @values, i64 0, i64 1) to i8*)), !dbg !83
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread2, i32 %1)
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread1 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread1, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %2 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread1, align 8, !dbg !84, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %call3 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %2, i8** null), !dbg !87
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread2 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread2, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %3 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread2, align 8, !dbg !88, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %call4 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %3, i8** null), !dbg !89
  call void @wrapper_exit_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !90
  ret i32 0, !dbg !90
}
</code></pre></div>

???
<!-- TODO -->
The first instrumentation call in the main thread registers the main thread with the Scheduler.
This allows the Scheduler to later identify the main thread, for example to determine whether or note
the main thread is finished.

---
count: false
<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define i32 @main() local_unnamed_addr #3 !dbg !78 {
  call void @wrapper_register_main_thread(), !dbg !81
* call void @wrapper_enter_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !81
  %0 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread1, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 28)
  %call1 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread1, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast ([2 x i32]* @values to i8*)), !dbg !82
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread1, i32 %0)
  %1 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 29)
  %call2 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread2, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast (i32* getelementptr inbounds ([2 x i32], [2 x i32]* @values, i64 0, i64 1) to i8*)), !dbg !83
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread2, i32 %1)
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread1 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread1, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %2 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread1, align 8, !dbg !84, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %call3 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %2, i8** null), !dbg !87
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread2 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread2, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %3 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread2, align 8, !dbg !88, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %call4 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %3, i8** null), !dbg !89
* call void @wrapper_exit_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !90
  ret i32 0, !dbg !90
}
</code></pre></div>

???
At the entry point and at each exit point of the function, the instrumentation pass inserts calls
to the schedulers enter/exit functions. These calls allow the Scheduler to keep track of the call 
stack of a thread. This is useful for bug reports, but also for knowing when a thread is finished 
executing and may be joined.

---
count: false
<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define i32 @main() local_unnamed_addr #3 !dbg !78 {
  call void @wrapper_register_main_thread(), !dbg !81
  call void @wrapper_enter_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !81
* %0 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread1, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 28)
* %call1 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread1, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast ([2 x i32]* @values to i8*)), !dbg !82
* call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread1, i32 %0)
  %1 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 29)
  %call2 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread2, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast (i32* getelementptr inbounds ([2 x i32], [2 x i32]* @values, i64 0, i64 1) to i8*)), !dbg !83
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread2, i32 %1)
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread1 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread1, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %2 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread1, align 8, !dbg !84, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %call3 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %2, i8** null), !dbg !87
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread2 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread2, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %3 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread2, align 8, !dbg !88, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %call4 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %3, i8** null), !dbg !89
  call void @wrapper_exit_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !90
  ret i32 0, !dbg !90
}
</code></pre></div>

???
All thread creation instructions in the original program are wrapped between two calls to Scheduler 
functions, which register the thread to be created.

---
count: false
<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define i32 @main() local_unnamed_addr #3 !dbg !78 {
  call void @wrapper_register_main_thread(), !dbg !81
  call void @wrapper_enter_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !81
* %0 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread1, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 28)
* %call1 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread1, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast ([2 x i32]* @values to i8*)), !dbg !82
* call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread1, i32 %0)
  %1 = call i32 @wrapper_post_spawn_instruction(%struct._opaque_pthread_t** @thread2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 29)
  %call2 = tail call i32 @pthread_create(%struct._opaque_pthread_t** nonnull @thread2, %struct._opaque_pthread_attr_t* null, i8* (i8*)* nonnull @_Z14thread_routinePv, i8* bitcast (i32* getelementptr inbounds ([2 x i32], [2 x i32]* @values, i64 0, i64 1) to i8*)), !dbg !83
  call void @wrapper_register_thread(%struct._opaque_pthread_t** @thread2, i32 %1)
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread1 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread1, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
  %2 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread1, align 8, !dbg !84, !tbaa !85
* call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 31)
* %call3 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %2, i8** null), !dbg !87
  call void @wrapper_post_memory_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_t** @thread2 to i8*), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @_mem_loc_name_thread2, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %3 = load %struct._opaque_pthread_t*, %struct._opaque_pthread_t** @thread2, align 8, !dbg !88, !tbaa !85
  call void @wrapper_post_pthread_join_instruction(%struct._opaque_pthread_t* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 32)
  %call4 = tail call i32 @"\01_pthread_join"(%struct._opaque_pthread_t* %3, i8** null), !dbg !89
  call void @wrapper_exit_function(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_recrep_function_name_main, i32 0, i32 0)), !dbg !90
  ret i32 0, !dbg !90
}
</code></pre></div>

???
A similar scheduler call is inserted before join instructions.

BRIDGE FROM:
The next snippet shows the LLVM IR of a thread start_routine.

---
count: false
<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define noalias nonnull i8* @_Z14thread_routinePv(i8* nocapture readonly %arg) #0 !dbg !59 {
  call void @wrapper_enter_function(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @_recrep_function_name__Z14thread_routinePv, i32 0, i32 0)), !dbg !65
  tail call void @llvm.dbg.value(metadata i8* %arg, i64 0, metadata !63, metadata !66), !dbg !65
  %0 = bitcast i8* %arg to i32*, !dbg !67
  %1 = bitcast i32* %0 to i8*, !dbg !68
  call void @wrapper_post_memory_instruction(i32 0, i8* %1, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @_mem_loc_name_, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 16)
  %2 = load i32, i32* %0, align 4, !dbg !68, !tbaa !69
  tail call void @llvm.dbg.value(metadata i32 %2, i64 0, metadata !64, metadata !66), !dbg !73
  call void @wrapper_post_lock_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_mutex_t* @mutex to i8*), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @_mem_loc_name_mutex, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 18)
  %call = tail call i32 @pthread_mutex_lock(%struct._opaque_pthread_mutex_t* nonnull @mutex), !dbg !74
  call void @wrapper_post_memory_instruction(i32 1, i8* bitcast (i32* @x to i8*), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @_mem_loc_name_x, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 19)
  store i32 %2, i32* @x, align 4, !dbg !75, !tbaa !69
  call void @wrapper_post_lock_instruction(i32 1, i8* bitcast (%struct._opaque_pthread_mutex_t* @mutex to i8*), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @_mem_loc_name_mutex, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 20)
  %call1 = tail call i32 @pthread_mutex_unlock(%struct._opaque_pthread_mutex_t* nonnull @mutex), !dbg !76
  call void @wrapper_exit_function(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @_recrep_function_name__Z14thread_routinePv, i32 0, i32 0)), !dbg !77
  tail call void @pthread_exit(i8* null) #6, !dbg !77
}
</code></pre></div>

---
count: false
<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define noalias nonnull i8* @_Z14thread_routinePv(i8* nocapture readonly %arg) #0 !dbg !59 {
  call void @wrapper_enter_function(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @_recrep_function_name__Z14thread_routinePv, i32 0, i32 0)), !dbg !65
  tail call void @llvm.dbg.value(metadata i8* %arg, i64 0, metadata !63, metadata !66), !dbg !65
  %0 = bitcast i8* %arg to i32*, !dbg !67
  %1 = bitcast i32* %0 to i8*, !dbg !68
* call void @wrapper_post_memory_instruction(i32 0, i8* %1, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @_mem_loc_name_, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 16)
* %2 = load i32, i32* %0, align 4, !dbg !68, !tbaa !69
  tail call void @llvm.dbg.value(metadata i32 %2, i64 0, metadata !64, metadata !66), !dbg !73
  call void @wrapper_post_lock_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_mutex_t* @mutex to i8*), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @_mem_loc_name_mutex, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 18)
  %call = tail call i32 @pthread_mutex_lock(%struct._opaque_pthread_mutex_t* nonnull @mutex), !dbg !74
* call void @wrapper_post_memory_instruction(i32 1, i8* bitcast (i32* @x to i8*), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @_mem_loc_name_x, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 19)
* store i32 %2, i32* @x, align 4, !dbg !75, !tbaa !69
  call void @wrapper_post_lock_instruction(i32 1, i8* bitcast (%struct._opaque_pthread_mutex_t* @mutex to i8*), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @_mem_loc_name_mutex, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 20)
  %call1 = tail call i32 @pthread_mutex_unlock(%struct._opaque_pthread_mutex_t* nonnull @mutex), !dbg !76
  call void @wrapper_exit_function(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @_recrep_function_name__Z14thread_routinePv, i32 0, i32 0)), !dbg !77
  tail call void @pthread_exit(i8* null) #6, !dbg !77
}
</code></pre></div>

???
Before each memory access, threads call wrapper_post_memory_instruction and pass relevant data 
as arguments, such as the address of the operand, whether the access is a load or a store and 
debug information such as the filename and line number of the instruction in the original source 
code.

---
count: false
<div class="code_right" style="width: 100%;"><pre><code class="language-cpp">
define noalias nonnull i8* @_Z14thread_routinePv(i8* nocapture readonly %arg) #0 !dbg !59 {
  call void @wrapper_enter_function(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @_recrep_function_name__Z14thread_routinePv, i32 0, i32 0)), !dbg !65
  tail call void @llvm.dbg.value(metadata i8* %arg, i64 0, metadata !63, metadata !66), !dbg !65
  %0 = bitcast i8* %arg to i32*, !dbg !67
  %1 = bitcast i32* %0 to i8*, !dbg !68
  call void @wrapper_post_memory_instruction(i32 0, i8* %1, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @_mem_loc_name_, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 16)
  %2 = load i32, i32* %0, align 4, !dbg !68, !tbaa !69
  tail call void @llvm.dbg.value(metadata i32 %2, i64 0, metadata !64, metadata !66), !dbg !73
* call void @wrapper_post_lock_instruction(i32 0, i8* bitcast (%struct._opaque_pthread_mutex_t* @mutex to i8*), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @_mem_loc_name_mutex, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 18)
* %call = tail call i32 @pthread_mutex_lock(%struct._opaque_pthread_mutex_t* nonnull @mutex), !dbg !74
  call void @wrapper_post_memory_instruction(i32 1, i8* bitcast (i32* @x to i8*), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @_mem_loc_name_x, i32 0, i32 0), i8 0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 19)
  store i32 %2, i32* @x, align 4, !dbg !75, !tbaa !69
* call void @wrapper_post_lock_instruction(i32 1, i8* bitcast (%struct._opaque_pthread_mutex_t* @mutex to i8*), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @_mem_loc_name_mutex, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @"_recrep_file_name_./examples/data_race_fixed_pthread.cpp", i32 0, i32 0), i32 20)
* %call1 = tail call i32 @pthread_mutex_unlock(%struct._opaque_pthread_mutex_t* nonnull @mutex), !dbg !76
  call void @wrapper_exit_function(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @_recrep_function_name__Z14thread_routinePv, i32 0, i32 0)), !dbg !77
  tail call void @pthread_exit(i8* null) #6, !dbg !77
}
</code></pre></div>

???
Similar calls are inserted before instructions operating on locks.

BRIDGE:
Now I showed you what the instrumented program looks like, let's look at the Scheduler's side.

<!-- <<< -->

<!-- >>> Slide -->

<!-- ////////// -->




      </textarea>
      
      <script src="../libs/mermaid/dist/mermaid.js"></script>
      <link rel="stylesheet" href="../libs/mermaid/dist/mermaid.forest.css">
      <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
      <script>
         var slideshow = remark.create({ 
            ratio: '16:9',
            highlightLanguage: 'cpp',
            highlightStyle: 'github',
            highlightLines: true
         });
         mermaid.initialize({ 
            startOnLoad: false,
            cloneCssStyles: false
         });
         function initMermaid(s) {
            var diagrams = document.querySelectorAll('.mermaid');
            var i;
            for (i=0; i < diagrams.length; i++) {
               if(diagrams[i].offsetWidth>0){
                  mermaid.init(undefined, diagrams[i]);
               }
            }
         }
         slideshow.on('afterShowSlide', initMermaid);
         initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);
      </script>
      
   </body>
</html>
